<!--LEGAL-DNA:{"jurisdiction":"US/MN/Baxter","export_tag":"EAR99","spdx":"MIT","artifact_time":1765689558505,"def_pub":"OIN","consent_req":true,"city":"Baxter"}-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#151515" />
  <title>Aperture Mobile Architect ‚Äî WebGL 3D Editor (FULLY FUNCTIONAL)</title>
  <style>
    :root{
      --bg:#151515;
      --panel:#1e1e1e;
      --panel2:#252526;
      --accent:#f58025;
      --muted:rgba(255,255,255,.75);
      --sa-top: env(safe-area-inset-top, 0px);
      --sa-right: env(safe-area-inset-right, 0px);
      --sa-bottom: env(safe-area-inset-bottom, 0px);
      --sa-left: env(safe-area-inset-left, 0px);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      touch-action:none;              /* global default (canvas/editor) */
      user-select:none;
      -webkit-user-select:none;
      color:white;
    }
    canvas#gl{
      position:absolute; inset:0;
      width:100vw; height:100vh;
      display:block;
      touch-action:none;
    }

    #ui{ position:absolute; inset:0; pointer-events:none; }

    /* Scrim so you can always back out by tapping outside */
    #scrim{
      pointer-events:none;
      position:absolute; inset:0;
      background:rgba(0,0,0,.45);
      opacity:0;
      transition:opacity .18s ease;
      z-index:18;
    }
    #scrim.open{ pointer-events:auto; opacity:1; }

    .btn{
      pointer-events:auto;
      position:absolute;
      width:54px; height:54px;
      border-radius:16px;
      border:2px solid rgba(255,255,255,.20);
      background:rgba(0,0,0,.55);
      color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-size:20px;
      touch-action:manipulation;
      backdrop-filter: blur(6px);
    }
    .btn:active{ transform:scale(.95); background:var(--accent); border-color:var(--accent); }

    #btn-add{ top:calc(16px + var(--sa-top)); left:calc(16px + var(--sa-left)); font-size:22px; z-index:30; }
    #btn-del{ top:calc(16px + var(--sa-top)); left:calc(82px + var(--sa-left)); z-index:30; }
    #btn-help{ top:calc(16px + var(--sa-top)); right:calc(82px + var(--sa-right)); font-size:18px; z-index:30; }
    #btn-term{ top:calc(16px + var(--sa-top)); right:calc(16px + var(--sa-right)); font-size:18px; z-index:30; }
    #btn-import{ top:calc(82px + var(--sa-top)); right:calc(16px + var(--sa-right)); font-size:18px; z-index:30; }

    #picker{
      pointer-events:auto;
      position:absolute;
      left:calc(16px + var(--sa-left));
      top:calc(78px + var(--sa-top));
      width:240px;
      padding:10px;
      border-radius:16px;
      border:2px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.55);
      backdrop-filter: blur(6px);
      display:none;
      z-index:30;
      touch-action:manipulation;
    }
    #picker.open{ display:block; }
    .pick-row{ display:flex; gap:8px; flex-wrap:wrap; }
    .pill{
      border:2px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 10px;
      border-radius:14px;
      font-weight:900;
      font-size:12px;
      letter-spacing:.3px;
      touch-action:manipulation;
    }
    .pill:active{ background:var(--accent); border-color:var(--accent); }

    #hint{
      position:absolute;
      left:calc(16px + var(--sa-left));
      bottom:calc(16px + var(--sa-bottom));
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      color:var(--muted);
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      max-width:86vw;
      line-height:1.25;
      pointer-events:none;
      white-space:pre-line;
      display:none;
      z-index:30;
    }

    /* Terminal drawer */
    #drawer{
      position:absolute; left:0; right:0; bottom:0;
      height:50vh;
      background:var(--panel);
      border-top:4px solid var(--accent);
      transform:translateY(110%);
      transition: transform .25s cubic-bezier(.2,.8,.2,1);
      z-index:22;
      pointer-events:auto;
      display:flex; flex-direction:column;
      box-shadow:0 -10px 30px rgba(0,0,0,.75);
      touch-action:auto;
    }
    #drawer.open{ transform:translateY(0); }
    #drawerHead{
      background:var(--panel2);
      padding:12px;
      padding-top:calc(12px + var(--sa-top));
      display:flex; align-items:center; justify-content:space-between;
      font-weight:900; letter-spacing:.7px;
    }
    #btn-close{
      border:none; background:none; color:#aaa;
      font-size:20px; padding:10px; border-radius:12px;
      touch-action:manipulation;
    }
    #btn-close:active{ background:rgba(255,255,255,.08); }

    #code{
      flex:1;
      margin:0;
      padding:12px;
      overflow:auto;
      background:#141414;
      color:#d4d4d4;
      font:13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre;
      touch-action:auto;
      user-select:text;
      -webkit-user-select:text;
    }
    #preview{
      height:120px;
      width:100%;
      border:0;
      background:#fff;
    }

    /* Import drawer */
    #importDrawer{
      position:absolute; left:0; right:0; bottom:0;
      height:60vh;
      background:var(--panel);
      border-top:4px solid #00aaff;
      transform:translateY(110%);
      transition: transform .25s cubic-bezier(.2,.8,.2,1);
      z-index:24;
      pointer-events:auto;
      display:flex; flex-direction:column;
      box-shadow:0 -10px 30px rgba(0,0,0,.75);
      touch-action:auto;
    }
    #importDrawer.open{ transform:translateY(0); }
    #importHead{
      background:var(--panel2);
      padding:12px;
      padding-top:calc(12px + var(--sa-top));
      display:flex; align-items:center; justify-content:space-between;
      font-weight:900; letter-spacing:.7px;
    }
    #btn-import-close{
      border:none; background:none; color:#aaa;
      font-size:20px; padding:10px; border-radius:12px;
      touch-action:manipulation;
    }
    #btn-import-close:active{ background:rgba(255,255,255,.08); }

    #importBody{
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:10px;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      touch-action:auto;
    }
    #importText{
      width:100%;
      min-height:180px;
      resize:none;
      border-radius:14px;
      border:2px solid rgba(255,255,255,.15);
      background:#121212;
      color:#eaeaea;
      padding:10px;
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      outline:none;

      /* CRITICAL: allow real text interaction on mobile */
      touch-action:auto !important;
      user-select:text !important;
      -webkit-user-select:text !important;
      -webkit-touch-callout:default !important;
    }
    #importRow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .smallBtn{
      pointer-events:auto;
      border-radius:14px;
      border:2px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:10px 12px;
      font-weight:900;
      letter-spacing:.4px;
      font-size:12px;
      touch-action:manipulation;
    }
    .smallBtn:active{ background:var(--accent); border-color:var(--accent); }
    .smallBtn.blue:active{ background:#00aaff; border-color:#00aaff; }

    #importStats{
      color:rgba(255,255,255,.75);
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-line;
      user-select:text;
      -webkit-user-select:text;
      touch-action:auto;
    }

    #fatal{
      position:absolute; inset:0;
      display:none;
      align-items:flex-start; justify-content:flex-start;
      padding:16px;
      background:#0b0b0b;
      color:#fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      z-index:999;
      user-select:text;
      -webkit-user-select:text;
      touch-action:auto;
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>

  <div id="ui">
    <div id="scrim"></div>

    <button id="btn-add" class="btn" type="button" aria-label="Add block">Ôºã</button>
    <button id="btn-del" class="btn" type="button" aria-label="Delete selected">üóë</button>
    <button id="btn-help" class="btn" type="button" aria-label="Help">‚ùî</button>
    <button id="btn-term" class="btn" type="button" aria-label="Terminal">üíª</button>
    <button id="btn-import" class="btn" type="button" aria-label="Import HTML">üì•</button>

    <div id="picker" aria-label="Block type picker">
      <div style="font-weight:900; letter-spacing:.6px; margin:0 0 8px 2px; color:rgba(255,255,255,.85); font-size:12px;">
        ADD BLOCK
      </div>
      <div class="pick-row">
        <button class="pill" data-type="h1">H1</button>
        <button class="pill" data-type="div">DIV</button>
        <button class="pill" data-type="img">IMG</button>
      </div>
      <div style="margin-top:10px; color:rgba(255,255,255,.65); font-size:11px; line-height:1.25;">
        Drag cube = move (snapped, no overlap). Drag empty = orbit.<br>
        Pinch = zoom. Two-finger drag = pan. Same cell = stack.
      </div>
    </div>

    <div id="hint"></div>

    <div id="drawer" role="dialog" aria-label="Aperture Mobile Terminal" aria-hidden="true">
      <div id="drawerHead">
        <div>APERTURE MOBILE TERMINAL</div>
        <button id="btn-close" type="button" aria-label="Close">‚úï</button>
      </div>
      <pre id="code">// Scanner Empty</pre>
      <iframe id="preview" sandbox="allow-same-origin" title="HTML Preview"></iframe>
    </div>

    <div id="importDrawer" role="dialog" aria-label="HTML Import Tool" aria-hidden="true">
      <div id="importHead">
        <div>HTML ‚Üí BLOCK VISUALIZER</div>
        <button id="btn-import-close" type="button" aria-label="Close">‚úï</button>
      </div>
      <div id="importBody">
        <div style="color:rgba(255,255,255,.8); font-size:12px; line-height:1.25;">
          Paste HTML. It parses elements (safe, no script execution) and spawns snapped blocks (no overlap; same cell stacks).
          Tap outside or press ‚úï to exit. Phone back button also closes.
        </div>

        <textarea id="importText" spellcheck="false" placeholder="Paste HTML here (fragment or full document)..."></textarea>

        <div id="importRow">
          <button id="btn-import-paste" class="smallBtn blue" type="button">PASTE CLIPBOARD</button>
          <button id="btn-import-visualize" class="smallBtn blue" type="button">VISUALIZE</button>
          <button id="btn-import-clear" class="smallBtn" type="button">CLEAR</button>
          <button id="btn-import-focus" class="smallBtn" type="button">FOCUS</button>
        </div>

        <div id="importStats"></div>

        <div style="color:rgba(255,255,255,.65); font-size:11px; line-height:1.25;">
          Safety + usability:
          ‚Ä¢ textarea uses real text selection, paste, scroll (overrides global touch-action/user-select).
          ‚Ä¢ Scrim + back button closes drawers.
          ‚Ä¢ Import capped for mobile stability.
        </div>
      </div>
    </div>
  </div>

  <div id="fatal"></div>

  <script>
    (() => {
      const fatalEl = document.getElementById('fatal');
      const die = (msg) => {
        fatalEl.style.display = "flex";
        fatalEl.textContent = msg;
        throw new Error(msg);
      };
      window.addEventListener('error', (e)=>{ die("[JS ERROR]\n" + (e.error && e.error.stack ? e.error.stack : e.message)); });
      window.addEventListener('unhandledrejection', (e)=>{ die("[PROMISE REJECT]\n" + (e.reason && e.reason.stack ? e.reason.stack : String(e.reason))); });

      const canvas = document.getElementById('gl');
      const gl = canvas.getContext('webgl', { antialias:true, alpha:false, depth:true, premultipliedAlpha:false });
      if (!gl) die("WebGL not available.");

      const btnAdd = document.getElementById('btn-add');
      const btnDel = document.getElementById('btn-del');
      const btnHelp = document.getElementById('btn-help');
      const btnTerm = document.getElementById('btn-term');
      const btnImport = document.getElementById('btn-import');

      const picker = document.getElementById('picker');
      const drawer = document.getElementById('drawer');
      const btnClose = document.getElementById('btn-close');
      const codeEl = document.getElementById('code');
      const preview = document.getElementById('preview');
      const hint = document.getElementById('hint');

      const scrim = document.getElementById('scrim');

      const importDrawer = document.getElementById('importDrawer');
      const btnImportClose = document.getElementById('btn-import-close');
      const importText = document.getElementById('importText');
      const importStats = document.getElementById('importStats');
      const btnImportPaste = document.getElementById('btn-import-paste');
      const btnImportVisualize = document.getElementById('btn-import-visualize');
      const btnImportClear = document.getElementById('btn-import-clear');
      const btnImportFocus = document.getElementById('btn-import-focus');

      // ---------- DPI resize ----------
      const DPR = () => Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      function resize(){
        const dpr = DPR();
        const w = Math.floor(innerWidth * dpr);
        const h = Math.floor(innerHeight * dpr);
        if (canvas.width !== w || canvas.height !== h){
          canvas.width = w; canvas.height = h;
          canvas.style.width = innerWidth + "px";
          canvas.style.height = innerHeight + "px";
          gl.viewport(0,0,w,h);
        }
      }
      addEventListener('resize', resize, { passive:true });
      resize();

      // ---------- vec3 ----------
      const v3=(x=0,y=0,z=0)=>({x,y,z});
      const add=(a,b)=>v3(a.x+b.x,a.y+b.y,a.z+b.z);
      const sub=(a,b)=>v3(a.x-b.x,a.y-b.y,a.z-b.z);
      const mul=(a,s)=>v3(a.x*s,a.y*s,a.z*s);
      const cross=(a,b)=>v3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);
      const len=(a)=>Math.hypot(a.x,a.y,a.z);
      const norm=(a)=>{ const L=len(a)||1; return v3(a.x/L,a.y/L,a.z/L); };
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

      // ---------- mat4 (COLUMN-MAJOR) ----------
      const m4 = {
        multiply(a,b){
          const o = new Float32Array(16);
          const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
          const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
          const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
          const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

          const b00=b[0],b01=b[1],b02=b[2],b03=b[3];
          const b10=b[4],b11=b[5],b12=b[6],b13=b[7];
          const b20=b[8],b21=b[9],b22=b[10],b23=b[11];
          const b30=b[12],b31=b[13],b32=b[14],b33=b[15];

          o[0]=a00*b00 + a10*b01 + a20*b02 + a30*b03;
          o[1]=a01*b00 + a11*b01 + a21*b02 + a31*b03;
          o[2]=a02*b00 + a12*b01 + a22*b02 + a32*b03;
          o[3]=a03*b00 + a13*b01 + a23*b02 + a33*b03;

          o[4]=a00*b10 + a10*b11 + a20*b12 + a30*b13;
          o[5]=a01*b10 + a11*b11 + a21*b12 + a31*b13;
          o[6]=a02*b10 + a12*b11 + a22*b12 + a32*b13;
          o[7]=a03*b10 + a13*b11 + a23*b12 + a33*b13;

          o[8]=a00*b20 + a10*b21 + a20*b22 + a30*b23;
          o[9]=a01*b20 + a11*b21 + a21*b22 + a31*b23;
          o[10]=a02*b20 + a12*b21 + a22*b22 + a32*b23;
          o[11]=a03*b20 + a13*b21 + a23*b22 + a33*b23;

          o[12]=a00*b30 + a10*b31 + a20*b32 + a30*b33;
          o[13]=a01*b30 + a11*b31 + a21*b32 + a31*b33;
          o[14]=a02*b30 + a12*b31 + a22*b32 + a32*b33;
          o[15]=a03*b30 + a13*b31 + a23*b32 + a33*b33;
          return o;
        },
        perspective(fovy, aspect, near, far){
          const f = 1.0 / Math.tan(fovy / 2);
          const nf = 1 / (near - far);
          const o = new Float32Array(16);
          o[0] = f / aspect;
          o[5] = f;
          o[10] = (far + near) * nf;
          o[11] = -1;
          o[14] = (2 * far * near) * nf;
          return o;
        },
        lookAt(eye, center, up){
          const o = new Float32Array(16);
          let z0 = eye.x - center.x, z1 = eye.y - center.y, z2 = eye.z - center.z;
          let L = Math.hypot(z0,z1,z2);
          if (L === 0) { z2 = 1; }
          else { z0/=L; z1/=L; z2/=L; }

          let x0 = up.y * z2 - up.z * z1;
          let x1 = up.z * z0 - up.x * z2;
          let x2 = up.x * z1 - up.y * z0;
          L = Math.hypot(x0,x1,x2);
          if (L === 0){ x0=0; x1=0; x2=0; }
          else { x0/=L; x1/=L; x2/=L; }

          let y0 = z1 * x2 - z2 * x1;
          let y1 = z2 * x0 - z0 * x2;
          let y2 = z0 * x1 - z1 * x0;

          o[0]=x0; o[1]=y0; o[2]=z0; o[3]=0;
          o[4]=x1; o[5]=y1; o[6]=z1; o[7]=0;
          o[8]=x2; o[9]=y2; o[10]=z2; o[11]=0;
          o[12]=-(x0*eye.x + x1*eye.y + x2*eye.z);
          o[13]=-(y0*eye.x + y1*eye.y + y2*eye.z);
          o[14]=-(z0*eye.x + z1*eye.y + z2*eye.z);
          o[15]=1;
          return o;
        },
        invert(a){
          const o = new Float32Array(16);
          const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
          const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
          const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
          const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;

          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) return null;
          det = 1.0 / det;

          o[0] = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
          o[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
          o[2] = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
          o[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
          o[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
          o[5] = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
          o[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
          o[7] = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
          o[8] = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
          o[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
          o[10]= ( a30 * b04 - a31 * b02 + a33 * b00) * det;
          o[11]= (-a20 * b04 + a21 * b02 - a23 * b00) * det;
          o[12]= (-a10 * b09 + a11 * b07 - a12 * b06) * det;
          o[13]= ( a00 * b09 - a01 * b07 + a02 * b06) * det;
          o[14]= (-a30 * b03 + a31 * b01 - a32 * b00) * det;
          o[15]= ( a20 * b03 - a21 * b01 + a22 * b00) * det;
          return o;
        }
      };

      function unproject(nx, ny, nz, invVP){
        const x=nx, y=ny, z=nz, w=1;
        const ox = invVP[0]*x + invVP[4]*y + invVP[8]*z + invVP[12]*w;
        const oy = invVP[1]*x + invVP[5]*y + invVP[9]*z + invVP[13]*w;
        const oz = invVP[2]*x + invVP[6]*y + invVP[10]*z + invVP[14]*w;
        const ow = invVP[3]*x + invVP[7]*y + invVP[11]*z + invVP[15]*w;
        if (ow === 0) return null;
        return v3(ox/ow, oy/ow, oz/ow);
      }

      // ---------- Shaders ----------
      function compile(type, src){
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
          const e = gl.getShaderInfoLog(s) || "unknown";
          gl.deleteShader(s);
          die("Shader compile error:\n" + e);
        }
        return s;
      }
      function link(vs, fs){
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
          const e = gl.getProgramInfoLog(p) || "unknown";
          gl.deleteProgram(p);
          die("Program link error:\n" + e);
        }
        return p;
      }

      const VS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        uniform mat4 u_vp;
        uniform vec3 u_objPos;
        uniform float u_objSize;
        varying vec3 v_nrm;
        void main(){
          vec3 p = a_pos * u_objSize + u_objPos;
          v_nrm = a_nrm;
          gl_Position = u_vp * vec4(p, 1.0);
        }
      `;
      const FS = `
        precision mediump float;
        uniform vec3 u_color;
        uniform vec3 u_lightDir;
        uniform float u_alpha;
        varying vec3 v_nrm;
        void main(){
          float ndl = max(dot(normalize(v_nrm), normalize(u_lightDir)), 0.0);
          float shade = 0.25 + ndl * 0.75;
          gl_FragColor = vec4(u_color * shade, u_alpha);
        }
      `;

      const prog = link(compile(gl.VERTEX_SHADER, VS), compile(gl.FRAGMENT_SHADER, FS));
      gl.useProgram(prog);

      const loc = {
        a_pos: gl.getAttribLocation(prog, "a_pos"),
        a_nrm: gl.getAttribLocation(prog, "a_nrm"),
        u_vp: gl.getUniformLocation(prog, "u_vp"),
        u_objPos: gl.getUniformLocation(prog, "u_objPos"),
        u_objSize: gl.getUniformLocation(prog, "u_objSize"),
        u_color: gl.getUniformLocation(prog, "u_color"),
        u_lightDir: gl.getUniformLocation(prog, "u_lightDir"),
        u_alpha: gl.getUniformLocation(prog, "u_alpha"),
      };

      // ---------- Cube geometry ----------
      const cube = (() => {
        const P=[], N=[];
        function face(nx,ny,nz, ax,ay,az, bx,by,bz, cx,cy,cz, dx,dy,dz){
          const v = [
            ax,ay,az, bx,by,bz, cx,cy,cz,
            ax,ay,az, cx,cy,cz, dx,dy,dz
          ];
          for(let i=0;i<v.length;i+=3){ P.push(v[i],v[i+1],v[i+2]); N.push(nx,ny,nz); }
        }
        face(0,0,1,  -0.5,-0.5,0.5,  0.5,-0.5,0.5,  0.5,0.5,0.5,  -0.5,0.5,0.5);
        face(0,0,-1,  0.5,-0.5,-0.5, -0.5,-0.5,-0.5, -0.5,0.5,-0.5, 0.5,0.5,-0.5);
        face(1,0,0,   0.5,-0.5,0.5,  0.5,-0.5,-0.5,  0.5,0.5,-0.5,  0.5,0.5,0.5);
        face(-1,0,0,  -0.5,-0.5,-0.5, -0.5,-0.5,0.5, -0.5,0.5,0.5, -0.5,0.5,-0.5);
        face(0,1,0,   -0.5,0.5,0.5,  0.5,0.5,0.5,  0.5,0.5,-0.5, -0.5,0.5,-0.5);
        face(0,-1,0,  -0.5,-0.5,-0.5, 0.5,-0.5,-0.5, 0.5,-0.5,0.5, -0.5,-0.5,0.5);
        return { P:new Float32Array(P), N:new Float32Array(N), count:P.length/3 };
      })();

      const vboPos = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
      gl.bufferData(gl.ARRAY_BUFFER, cube.P, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(loc.a_pos);
      gl.vertexAttribPointer(loc.a_pos, 3, gl.FLOAT, false, 0, 0);

      const vboNrm = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboNrm);
      gl.bufferData(gl.ARRAY_BUFFER, cube.N, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(loc.a_nrm);
      gl.vertexAttribPointer(loc.a_nrm, 3, gl.FLOAT, false, 0, 0);

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearColor(0.08,0.08,0.08,1);

      // ---------- Scene ----------
      const UP = v3(0,1,0);
      const COLORS = {
        h1: [1.0, 0.855, 0.85],
        div:[0.88,0.88,0.88],
        img:[0.91,0.875,0.96],
        accent:[0.96,0.50,0.145],
        scanner:[0.96,0.50,0.145],
        other:[0.78,0.92,0.98]
      };

      const cam = {
        target: v3(0, 0, -140),
        yaw: 0.85,
        pitch: 0.60,
        dist: 820,
        fov: 70*Math.PI/180
      };

      const cubeSize = 70;
      const half = cubeSize * 0.5;
      const groundY = half;

      const scanner = { cx:0, cz:-360, w:600, d:320 };

      const state = {
        blocks: [],
        selected: null,
        dragging: null,
        dragStartGround: null,
        dragStartPos: null,
        pointers: new Map(),
        mode: "none",
        orbitLast: null,
        pinch: null,
        lastScan: 0,
        helpOn: false,

        // Drawer state for "back button closes"
        openPanel: null, // "terminal" | "import" | null
        suppressNextPop: false
      };

      function rid(){
        return (crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2));
      }

      function cameraEye(){
        const cp=Math.cos(cam.pitch), sp=Math.sin(cam.pitch);
        const cy=Math.cos(cam.yaw), sy=Math.sin(cam.yaw);
        const dir = v3(sy*cp, sp, cy*cp);
        return add(cam.target, mul(dir, cam.dist));
      }

      function getVP(){
        const aspect = canvas.width / canvas.height;
        const proj = m4.perspective(cam.fov, aspect, 0.1, 5000.0);
        const eye = cameraEye();
        const view = m4.lookAt(eye, cam.target, UP);
        const vp = m4.multiply(proj, view);
        return { proj, view, vp, eye };
      }

      function rayFromScreen(clientX, clientY){
        const nx = (clientX / innerWidth) * 2 - 1;
        const ny = 1 - (clientY / innerHeight) * 2;
        const { vp, eye } = getVP();
        const invVP = m4.invert(vp);
        if(!invVP) return null;

        const near = unproject(nx, ny, -1, invVP);
        const far  = unproject(nx, ny,  1, invVP);
        if(!near || !far) return null;

        const dir = norm(sub(far, near));
        return { o: eye, d: dir };
      }

      function intersectPlaneY(ray, y){
        const denom = ray.d.y;
        if(Math.abs(denom) < 1e-6) return null;
        const t = (y - ray.o.y) / denom;
        if(t <= 0) return null;
        return add(ray.o, mul(ray.d, t));
      }

      function intersectAABB(ray, min, max){
        let tmin=-Infinity, tmax=Infinity;
        for(const ax of ["x","y","z"]){
          const o = ray.o[ax], d = ray.d[ax];
          if(Math.abs(d) < 1e-8){
            if(o < min[ax] || o > max[ax]) return null;
          } else {
            let t1 = (min[ax] - o)/d;
            let t2 = (max[ax] - o)/d;
            if(t1>t2){ const tmp=t1; t1=t2; t2=tmp; }
            tmin = Math.max(tmin, t1);
            tmax = Math.min(tmax, t2);
            if(tmin>tmax) return null;
          }
        }
        if(tmax < 0) return null;
        return tmin >= 0 ? tmin : tmax;
      }

      function pickBlock(clientX, clientY){
        const ray = rayFromScreen(clientX, clientY);
        if(!ray) return null;
        let best=null, bestT=Infinity;
        for(const b of state.blocks){
          const p=b.pos;
          const min=v3(p.x-half, p.y-half, p.z-half);
          const max=v3(p.x+half, p.y+half, p.z+half);
          const t = intersectAABB(ray, min, max);
          if(t !== null && t < bestT){ bestT=t; best=b; }
        }
        return best;
      }

      // ---------- Grid + No-overlap stacking ----------
      const GRID = {
        cell: cubeSize,               // XZ footprint size
        yStep: cubeSize,              // vertical stacking step
        maxSpiral: 24                 // search radius for nearest free cell if needed
      };

      const snap = (v, s)=> Math.round(v / s) * s;
      const cellKey = (x,z)=> `${snap(x,GRID.cell)}|${snap(z,GRID.cell)}`;

      function stackLevelAt(key, ignoreId){
        let n = 0;
        for(const b of state.blocks){
          if(ignoreId && b.id === ignoreId) continue;
          if(cellKey(b.pos.x,b.pos.z) === key) n++;
        }
        return n;
      }

      function placeOnGrid(desiredX, desiredZ, idForIgnore, allowStack=true){
        const gx = snap(desiredX, GRID.cell);
        const gz = snap(desiredZ, GRID.cell);
        const key = `${gx}|${gz}`;

        if(allowStack){
          const level = stackLevelAt(key, idForIgnore);
          return { x:gx, z:gz, y:groundY + level*GRID.yStep };
        }

        // If stacking disabled: find nearest unoccupied cell
        for(let r=0; r<=GRID.maxSpiral; r++){
          for(let dz=-r; dz<=r; dz++){
            for(let dx=-r; dx<=r; dx++){
              if(Math.abs(dx)!==r && Math.abs(dz)!==r) continue;
              const x = gx + dx*GRID.cell;
              const z = gz + dz*GRID.cell;
              const k = `${x}|${z}`;
              if(stackLevelAt(k, idForIgnore) === 0){
                return { x, z, y:groundY };
              }
            }
          }
        }
        // Worst case: just stack
        const level = stackLevelAt(key, idForIgnore);
        return { x:gx, z:gz, y:groundY + level*GRID.yStep };
      }

      function normalizeAllBlocksToGrid(){
        // Re-pack blocks deterministically to avoid accidental overlaps from older state
        // Sort by current y then z then x so towers are preserved-ish
        const blocks = state.blocks.slice().sort((a,b)=>{
          const ak=cellKey(a.pos.x,a.pos.z), bk=cellKey(b.pos.x,b.pos.z);
          if(ak!==bk) return ak < bk ? -1 : 1;
          return a.pos.y - b.pos.y;
        });

        // Rebuild towers
        const towerCounts = new Map();
        for(const b of blocks){
          const x = snap(b.pos.x, GRID.cell);
          const z = snap(b.pos.z, GRID.cell);
          const k = `${x}|${z}`;
          const lvl = (towerCounts.get(k) || 0);
          towerCounts.set(k, lvl+1);
          b.pos.x = x;
          b.pos.z = z;
          b.pos.y = groundY + lvl*GRID.yStep;
        }
      }

      function addBlock(type){
        const id = rid();
        const desiredX = cam.target.x + (Math.random()*140-70);
        const desiredZ = cam.target.z + 120 + (Math.random()*80-40);
        const p = placeOnGrid(desiredX, desiredZ, id, true);
        const content = type==="h1" ? "Hello" : type==="div" ? "Box" : "";
        state.blocks.push({ id, type, content, pos: v3(p.x,p.y,p.z) });
        state.selected = id;
        scanNow();
      }

      function deleteSelected(){
        if(!state.selected) return;
        const i = state.blocks.findIndex(b => b.id === state.selected);
        if(i >= 0) state.blocks.splice(i,1);
        state.selected = null;
        // After deletion, re-pack tower levels so no floating gaps (optional but keeps it clean)
        normalizeAllBlocksToGrid();
        scanNow();
      }

      // Seed visible blocks (snapped, no overlap)
      addBlock("h1"); state.blocks[state.blocks.length-1].pos.x -= GRID.cell*2; state.blocks[state.blocks.length-1].pos.z -= GRID.cell*2;
      addBlock("div"); state.blocks[state.blocks.length-1].pos.x += GRID.cell*0; state.blocks[state.blocks.length-1].pos.z -= GRID.cell*2;
      addBlock("img"); state.blocks[state.blocks.length-1].pos.x += GRID.cell*2; state.blocks[state.blocks.length-1].pos.z -= GRID.cell*2;
      addBlock("div"); state.blocks[state.blocks.length-1].pos.x += GRID.cell*0; state.blocks[state.blocks.length-1].pos.z -= GRID.cell*0;
      normalizeAllBlocksToGrid();

      // ---------- Scanner ----------
      function escapeHTML(s){
        return String(s)
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }
      function inScanner(b){
        const left=scanner.cx-scanner.w/2, right=scanner.cx+scanner.w/2;
        const back=scanner.cz-scanner.d/2, front=scanner.cz+scanner.d/2;
        const p=b.pos;
        return (p.x>=left && p.x<=right && p.z>=back && p.z<=front);
      }
      function scanNow(){
        const active = state.blocks.filter(inScanner).sort((a,b)=>a.pos.x-b.pos.x);
        if(!active.length){
          codeEl.textContent = "// Scanner Empty";
          preview.srcdoc = "";
          return;
        }
        let code="", html="";
        for(const b of active){
          const t=(b.type||"div").toLowerCase();
          const c=b.content ?? "";
          if(t==="img"){
            const src = (String(c).trim().startsWith("http") || String(c).trim().startsWith("data:"))
              ? String(c).trim()
              : "data:image/svg+xml;charset=utf-8," + encodeURIComponent(
                  `<svg xmlns="http://www.w3.org/2000/svg" width="160" height="80">
                    <rect width="100%" height="100%" fill="#ddd"/>
                    <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#333"
                      font-family="Arial" font-size="14">IMG</text>
                  </svg>`
                );
            code += `<img src="${escapeHTML(src)}" alt="" />\n`;
            html += `<img src="${escapeHTML(src)}" alt="" style="margin:6px; max-height:80px; border:1px solid #ccc;" />`;
          } else {
            const safeTag = /^[a-z][a-z0-9-]*$/i.test(t) ? t : "div";
            code += `<${safeTag}>${escapeHTML(c)}</${safeTag}>\n`;
            html += `<${safeTag} style="margin:6px; padding:6px; border:1px solid #ccc; display:inline-block;">${escapeHTML(c)}</${safeTag}>`;
          }
        }
        codeEl.textContent = code;
        preview.srcdoc = `<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1">
          <style>body{margin:0;padding:8px;font-family:system-ui;background:#fff}</style></head><body>${html}</body></html>`;
      }

      // ---------- Rendering ----------
      function drawCube(pos, size, color, alpha){
        gl.uniform3f(loc.u_objPos, pos.x, pos.y, pos.z);
        gl.uniform1f(loc.u_objSize, size);
        gl.uniform3f(loc.u_color, color[0], color[1], color[2]);
        gl.uniform3f(loc.u_lightDir, -0.35, 0.85, 0.25);
        gl.uniform1f(loc.u_alpha, alpha);
        gl.drawArrays(gl.TRIANGLES, 0, cube.count);
      }

      function drawScanner(vp){
        gl.uniformMatrix4fv(loc.u_vp, false, vp);
        const y = 0.35;
        const left=scanner.cx-scanner.w/2, right=scanner.cx+scanner.w/2;
        const back=scanner.cz-scanner.d/2, front=scanner.cz+scanner.d/2;

        for(let z=back; z<=front; z+=70){
          for(let x=left; x<=right; x+=70){
            drawCube(v3(x, y, z), 1.2, COLORS.scanner, 0.12);
          }
        }
        drawCube(v3(left,  y, back),  2.4, COLORS.scanner, 0.65);
        drawCube(v3(right, y, back),  2.4, COLORS.scanner, 0.65);
        drawCube(v3(left,  y, front), 2.4, COLORS.scanner, 0.65);
        drawCube(v3(right, y, front), 2.4, COLORS.scanner, 0.65);
      }

      function render(){
        resize();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const { vp } = getVP();
        gl.uniformMatrix4fv(loc.u_vp, false, vp);

        for(let z=-900; z<=500; z+=90){
          for(let x=-900; x<=900; x+=90){
            drawCube(v3(x, 0.0, z), 1.2, [0.25,0.25,0.25], 0.10);
          }
        }

        drawScanner(vp);

        for(const b of state.blocks){
          const type = (b.type||"div").toLowerCase();
          const color = COLORS[type] || COLORS.other;
          drawCube(b.pos, cubeSize, color, 1.0);
          if(state.selected === b.id){
            drawCube(b.pos, cubeSize*1.08, COLORS.accent, 0.22);
          }
        }

        requestAnimationFrame(render);
      }

      // ---------- Panels + Back-out logic ----------
      const setPicker = (open)=> picker.classList.toggle("open", open);

      function setScrim(open){
        scrim.classList.toggle("open", open);
      }

      function openPanel(name){
        // name: "terminal" | "import"
        state.openPanel = name;
        drawer.classList.toggle("open", name==="terminal");
        drawer.setAttribute("aria-hidden", name==="terminal" ? "false" : "true");
        importDrawer.classList.toggle("open", name==="import");
        importDrawer.setAttribute("aria-hidden", name==="import" ? "false" : "true");
        setScrim(true);

        // Push a history state so Android back button closes panel
        state.suppressNextPop = true;
        history.pushState({ panel:name }, "");
        setTimeout(()=>{ state.suppressNextPop = false; }, 0);
      }

      function closePanels(){
        state.openPanel = null;
        drawer.classList.remove("open");
        drawer.setAttribute("aria-hidden","true");
        importDrawer.classList.remove("open");
        importDrawer.setAttribute("aria-hidden","true");
        setScrim(false);
      }

      window.addEventListener("popstate", (e)=>{
        // If a panel is open, back closes it
        if(state.openPanel){
          closePanels();
          return;
        }
        // Otherwise normal back behavior (browser decides)
      });

      // Tap outside to close
      scrim.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        closePanels();
      }, {passive:false});

      hint.textContent =
`Controls:
‚Ä¢ Drag cube: move snapped on ground (no overlap)
‚Ä¢ Drag empty: orbit camera
‚Ä¢ Pinch: zoom
‚Ä¢ Two-finger drag: pan target
Placement:
‚Ä¢ Same XZ cell stacks vertically (no collisions)
Tools:
‚Ä¢ Ôºã add block   üóë delete selected   üíª terminal   üì• import HTML
Exit:
‚Ä¢ Tap outside panel or press ‚úï or phone back button`;

      btnAdd.addEventListener("pointerdown", (e)=>{ e.preventDefault(); e.stopPropagation(); setPicker(!picker.classList.contains("open")); }, {passive:false});
      btnDel.addEventListener("pointerdown", (e)=>{ e.preventDefault(); e.stopPropagation(); deleteSelected(); }, {passive:false});
      btnTerm.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); openPanel("terminal"); }, {passive:false});
      btnClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanels(); }, {passive:false});
      btnHelp.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); state.helpOn=!state.helpOn; hint.style.display=state.helpOn?"block":"none"; }, {passive:false});

      btnImport.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); openPanel("import"); }, {passive:false});
      btnImportClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanels(); }, {passive:false});

      picker.addEventListener("pointerdown",(e)=>{
        const pill = e.target.closest(".pill");
        if(!pill) return;
        e.preventDefault(); e.stopPropagation();
        setPicker(false);
        addBlock(pill.dataset.type);
      }, {passive:false});

      // ---------- Import tool ----------
      function summarizeNode(el){
        const tag = el.tagName ? el.tagName.toLowerCase() : "div";
        if(tag === "img"){
          const src = el.getAttribute("src") || "";
          return { tag, content: src.slice(0, 300) };
        }
        const txt = (el.textContent || "").replace(/\s+/g," ").trim();
        const id = el.getAttribute && el.getAttribute("id") ? ("#" + el.getAttribute("id")) : "";
        const cls = el.getAttribute && el.getAttribute("class") ? ("." + el.getAttribute("class").trim().split(/\s+/).slice(0,2).join(".")) : "";
        const label = (id || cls) ? (id + cls) : "";
        const content = (txt || label || "").slice(0, 220);
        return { tag, content };
      }

      function parseHTMLToNodes(html){
        const MAX_NODES = 240;
        const MAX_DEPTH = 16;
        const doc = new DOMParser().parseFromString(String(html || ""), "text/html");
        const roots = (doc.body && doc.body.childNodes && doc.body.childNodes.length)
          ? Array.from(doc.body.childNodes)
          : Array.from(doc.childNodes);

        const out = [];
        const walk = (node, depth)=>{
          if(out.length >= MAX_NODES) return;
          if(depth > MAX_DEPTH) return;
          if(!node) return;

          if(node.nodeType === Node.ELEMENT_NODE){
            const tag = node.tagName.toLowerCase();
            if(tag === "script" || tag === "style" || tag === "meta" || tag === "link" || tag === "noscript") return;
            const s = summarizeNode(node);
            out.push({ tag: s.tag, content: s.content, depth });
          }

          const kids = node.childNodes ? Array.from(node.childNodes) : [];
          for(const k of kids) walk(k, depth+1);
        };

        for(const r of roots) walk(r, 0);
        return out;
      }

      function spawnNodesAsBlocks(nodes){
        if(!nodes.length) return 0;

        // Spawn in a snapped grid near the camera target; stacking happens automatically when same cell repeats.
        let spawned = 0;
        const cols = 10;
        const gapCells = 1; // 1 cell spacing (snapped)
        const startX = snap(cam.target.x - GRID.cell*4, GRID.cell);
        const startZ = snap(cam.target.z + GRID.cell*2, GRID.cell);

        for(let i=0;i<nodes.length;i++){
          const n = nodes[i];
          const id = rid();
          const desiredX = startX + (i % cols) * GRID.cell * gapCells;
          const desiredZ = startZ + Math.floor(i / cols) * GRID.cell * gapCells;
          const p = placeOnGrid(desiredX, desiredZ, id, true);
          state.blocks.push({ id, type:(n.tag||"div").toLowerCase(), content:(n.content||""), pos:v3(p.x,p.y,p.z) });
          state.selected = id;
          spawned++;
        }

        scanNow();
        return spawned;
      }

      function focusOnRecent(count){
        if(!count) return;
        const recent = state.blocks.slice(-count);
        if(!recent.length) return;

        let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
        for(const b of recent){
          minX=Math.min(minX,b.pos.x); maxX=Math.max(maxX,b.pos.x);
          minZ=Math.min(minZ,b.pos.z); maxZ=Math.max(maxZ,b.pos.z);
        }
        cam.target.x = (minX+maxX)/2;
        cam.target.z = (minZ+maxZ)/2;
        cam.target.y = 0;

        const span = Math.max(maxX-minX, maxZ-minZ);
        cam.dist = clamp(700 + span*1.2, 520, 2200);
      }

      function updateImportStats(extra=""){
        const txt = importText.value || "";
        const chars = txt.length;
        importStats.textContent =
          `Textarea: ${chars} chars\n` +
          `Paste: long-press works; button works when clipboard allowed.\n` +
          (extra ? (`\n${extra}`) : "");
      }

      // Keep stats current when typing/pasting normally
      importText.addEventListener("input", ()=> updateImportStats(), {passive:true});
      importText.addEventListener("focus", ()=> updateImportStats("Focused. Paste now."), {passive:true});

      btnImportClear.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        importText.value = "";
        updateImportStats("Cleared.");
      }, {passive:false});

      btnImportPaste.addEventListener("pointerdown", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        try{
          if(navigator.clipboard && navigator.clipboard.readText){
            const t = await navigator.clipboard.readText();
            if(!t){ updateImportStats("Clipboard empty."); return; }
            importText.focus();
            importText.value = t;
            updateImportStats(`Pasted ${t.length} chars from clipboard.`);
          } else {
            updateImportStats("Clipboard API unavailable here. Use long-press ‚Üí Paste.");
          }
        } catch(err){
          updateImportStats("Clipboard read blocked by browser permissions. Use long-press ‚Üí Paste.");
        }
      }, {passive:false});

      btnImportVisualize.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        const html = importText.value || "";
        const nodes = parseHTMLToNodes(html);
        const spawned = spawnNodesAsBlocks(nodes);
        normalizeAllBlocksToGrid(); // hard guarantee: no overlap even if weird input/order
        focusOnRecent(spawned);
        updateImportStats(`Parsed nodes: ${nodes.length}\nSpawned blocks: ${spawned}\n(Blocks snap; same cell stacks; no overlap.)`);
      }, {passive:false});

      btnImportFocus.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        focusOnRecent(Math.min(120, state.blocks.length));
        updateImportStats("Focused camera on recent blocks.");
      }, {passive:false});

      // ---------- Input (canvas) ----------
      canvas.addEventListener("pointerdown", (e)=>{
        // If a panel is open, ignore canvas input completely.
        if(state.openPanel) return;

        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        if(state.pointers.size === 2){
          state.mode="pinchpan";
          state.dragging=null;

          const pts=[...state.pointers.values()];
          const a=pts[0], b=pts[1];
          const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const dist=Math.hypot(a.x-b.x, a.y-b.y) || 1;

          state.pinch={
            startDist:dist,
            startMid:mid,
            startCamDist:cam.dist,
            startTarget:v3(cam.target.x, cam.target.y, cam.target.z)
          };
          return;
        }

        const picked = pickBlock(e.clientX, e.clientY);
        if(picked){
          state.mode="drag";
          state.dragging=picked.id;
          state.selected=picked.id;

          const ray = rayFromScreen(e.clientX, e.clientY);
          const g = ray ? intersectPlaneY(ray, groundY) : null;

          state.dragStartGround=g;
          state.dragStartPos=v3(picked.pos.x, picked.pos.y, picked.pos.z);
          scanNow();
          return;
        }

        state.mode="orbit";
        state.selected=null;
        state.orbitLast={ x:e.clientX, y:e.clientY };
      }, {passive:false});

      canvas.addEventListener("pointermove",(e)=>{
        if(state.openPanel) return;
        if(!state.pointers.has(e.pointerId)) return;

        e.preventDefault();
        state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        if(state.pointers.size === 2 && state.mode==="pinchpan" && state.pinch){
          const pts=[...state.pointers.values()];
          const a=pts[0], b=pts[1];
          const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const dist=Math.hypot(a.x-b.x, a.y-b.y) || 1;

          const scale = dist / (state.pinch.startDist || dist);
          cam.dist = clamp(state.pinch.startCamDist / scale, 320, 2400);

          const mdx = mid.x - state.pinch.startMid.x;
          const mdy = mid.y - state.pinch.startMid.y;

          const eye = cameraEye();
          const fwd = norm(sub(cam.target, eye));
          const right = norm(cross(fwd, UP));
          const fwdXZ = norm(v3(fwd.x,0,fwd.z));
          const rightXZ = norm(v3(right.x,0,right.z));

          const panFactor = (cam.dist / 900) * 1.05;
          const pan = add(mul(rightXZ, -mdx*panFactor), mul(fwdXZ, mdy*panFactor));
          cam.target = add(state.pinch.startTarget, pan);
          cam.target.y = 0;
          return;
        }

        if(state.mode==="drag" && state.dragging){
          const b = state.blocks.find(x=>x.id===state.dragging);
          if(!b) return;

          const ray = rayFromScreen(e.clientX, e.clientY);
          const g = ray ? intersectPlaneY(ray, groundY) : null;
          if(!g || !state.dragStartGround || !state.dragStartPos) return;

          const desiredX = state.dragStartPos.x + (g.x - state.dragStartGround.x);
          const desiredZ = state.dragStartPos.z + (g.z - state.dragStartGround.z);

          // Snap + stack: hard guarantee no overlap
          const p = placeOnGrid(desiredX, desiredZ, b.id, true);

          // If staying in same cell, preserve current tower level (prevents jitter)
          const oldKey = cellKey(b.pos.x,b.pos.z);
          const newKey = `${p.x}|${p.z}`;
          if(oldKey === newKey){
            // keep y as-is (still snapped from earlier)
          } else {
            b.pos.y = p.y;
          }

          b.pos.x = p.x;
          b.pos.z = p.z;

          const now = performance.now();
          if(now - state.lastScan > 120){ state.lastScan = now; scanNow(); }
          return;
        }

        if(state.mode==="orbit" && state.orbitLast){
          const dx=e.clientX-state.orbitLast.x;
          const dy=e.clientY-state.orbitLast.y;
          state.orbitLast.x=e.clientX;
          state.orbitLast.y=e.clientY;

          cam.yaw += dx * 0.0055;
          cam.pitch = clamp(cam.pitch - dy * 0.0055, 0.12, 1.35);
          return;
        }
      }, {passive:false});

      function endPointer(e){
        if(state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);
        if(state.pointers.size < 2 && state.mode==="pinchpan"){ state.mode="none"; state.pinch=null; }
        if(state.pointers.size === 0){
          state.mode="none";
          state.dragging=null;
          state.dragStartGround=null;
          state.dragStartPos=null;
          state.orbitLast=null;

          // On drag end, re-pack tower levels to guarantee no overlap and stable stacks
          normalizeAllBlocksToGrid();
          scanNow();
        }
      }
      canvas.addEventListener("pointerup", endPointer, {passive:true});
      canvas.addEventListener("pointercancel", endPointer, {passive:true});

      // ---------- Keyboard helpers (desktop) ----------
      window.addEventListener("keydown",(e)=>{
        if(e.key === "Escape"){
          if(state.openPanel) closePanels();
          else if(picker.classList.contains("open")) setPicker(false);
        }
        if(e.key === "i" || e.key === "I"){ openPanel("import"); }
      });

      // ---------- Start ----------
      updateImportStats("Ready.");
      scanNow();
      render();
    })();
  </script>
</body>
</html>