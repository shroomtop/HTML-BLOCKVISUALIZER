<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#151515" />
  <title>Aperture Mobile Architect ‚Äî 3D HTML Block Editor (ROUNDTRIP + NAV FIX)</title>
  <style>
    :root{
      --bg:#151515;
      --panel:#1e1e1e;
      --panel2:#252526;
      --accent:#f58025;
      --accent2:#00aaff;
      --muted:rgba(255,255,255,.75);
      --muted2:rgba(255,255,255,.55);
      --sa-top: env(safe-area-inset-top, 0px);
      --sa-right: env(safe-area-inset-right, 0px);
      --sa-bottom: env(safe-area-inset-bottom, 0px);
      --sa-left: env(safe-area-inset-left, 0px);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      color:white;
    }

    /* WebGL + HUD overlay */
    canvas#gl, canvas#hud{
      position:absolute; inset:0;
      width:100vw; height:100vh;
      display:block;
    }
    canvas#gl{ touch-action:none; }
    canvas#hud{ pointer-events:none; }

    #ui{ position:absolute; inset:0; pointer-events:none; }

    /* Scrim closes panels */
    #scrim{
      pointer-events:none;
      position:absolute; inset:0;
      background:rgba(0,0,0,.55);
      opacity:0;
      transition:opacity .16s ease;
      z-index:18;
    }
    #scrim.open{ pointer-events:auto; opacity:1; }

    /* Top buttons */
    .btn{
      pointer-events:auto;
      position:absolute;
      width:54px; height:54px;
      border-radius:16px;
      border:2px solid rgba(255,255,255,.20);
      background:rgba(0,0,0,.55);
      color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-size:20px;
      touch-action:manipulation;
      backdrop-filter: blur(6px);
    }
    .btn:active{ transform:scale(.95); background:var(--accent); border-color:var(--accent); }

    #btn-add{ top:calc(16px + var(--sa-top)); left:calc(16px + var(--sa-left)); font-size:22px; z-index:30; }
    #btn-del{ top:calc(16px + var(--sa-top)); left:calc(82px + var(--sa-left)); z-index:30; }
    #btn-help{ top:calc(16px + var(--sa-top)); right:calc(148px + var(--sa-right)); font-size:18px; z-index:30; }
    #btn-export{ top:calc(16px + var(--sa-top)); right:calc(82px + var(--sa-right)); font-size:18px; z-index:30; }
    #btn-import{ top:calc(16px + var(--sa-top)); right:calc(16px + var(--sa-right)); font-size:18px; z-index:30; }
    #btn-edit{ top:calc(82px + var(--sa-top)); right:calc(16px + var(--sa-right)); font-size:18px; z-index:30; }

    /* Picker */
    #picker{
      pointer-events:auto;
      position:absolute;
      left:calc(16px + var(--sa-left));
      top:calc(78px + var(--sa-top));
      width:min(92vw, 320px);
      padding:10px;
      border-radius:16px;
      border:2px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.62);
      backdrop-filter: blur(8px);
      display:none;
      z-index:30;
      touch-action:manipulation;
    }
    #picker.open{ display:block; }
    #pickerTabs{
      display:flex; gap:8px; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .tab{
      border:2px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 10px;
      border-radius:14px;
      font-weight:900;
      font-size:11px;
      letter-spacing:.3px;
      touch-action:manipulation;
    }
    .tab.on{ background:rgba(245,128,37,.25); border-color:rgba(245,128,37,.65); }
    .tab:active{ background:var(--accent); border-color:var(--accent); }

    .pick-grid{ display:none; gap:8px; flex-wrap:wrap; }
    .pick-grid.on{ display:flex; }
    .pill{
      border:2px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 10px;
      border-radius:14px;
      font-weight:900;
      font-size:12px;
      letter-spacing:.3px;
      touch-action:manipulation;
    }
    .pill:active{ background:var(--accent); border-color:var(--accent); }

    /* Hint */
    #hint{
      position:absolute;
      left:calc(16px + var(--sa-left));
      bottom:calc(16px + var(--sa-bottom));
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      color:var(--muted);
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      max-width:86vw;
      line-height:1.25;
      pointer-events:none;
      white-space:pre-line;
      display:none;
      z-index:30;
    }

    /* Unified Panel (modal) */
    .panel{
      position:absolute; left:0; right:0; bottom:0;
      height:min(68vh, 720px);
      background:var(--panel);
      border-top:4px solid var(--accent2);
      transform:translateY(110%);
      transition: transform .22s cubic-bezier(.2,.8,.2,1);
      z-index:22;
      pointer-events:auto;
      display:flex; flex-direction:column;
      box-shadow:0 -10px 30px rgba(0,0,0,.75);
      touch-action:auto;
      -webkit-overflow-scrolling:touch;
    }
    .panel.open{ transform:translateY(0); }

    .panelHead{
      background:var(--panel2);
      padding:12px;
      padding-top:calc(12px + var(--sa-top));
      display:flex; align-items:center; justify-content:space-between;
      gap:10px;
      font-weight:900; letter-spacing:.7px;
    }
    .panelTitle{
      display:flex; flex-direction:column; gap:6px;
      min-width:0;
    }
    .panelTitle b{
      font-size:12px;
      opacity:.95;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .panelTitle span{
      font:11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:var(--muted2);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .panelTools{
      display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;
      align-items:center;
    }
    .toolbtn{
      border-radius:12px;
      border:2px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:8px 10px;
      font-weight:900;
      letter-spacing:.4px;
      font-size:11px;
      touch-action:manipulation;
      pointer-events:auto;
      user-select:none;
      -webkit-user-select:none;
    }
    .toolbtn:active{ background:var(--accent); border-color:var(--accent); }
    .toolbtn.on{ background:rgba(0,170,255,.18); border-color:rgba(0,170,255,.55); }

    .xbtn{
      border:none; background:none; color:#aaa;
      font-size:20px; padding:10px; border-radius:12px;
      touch-action:manipulation;
      pointer-events:auto;
      user-select:none;
      -webkit-user-select:none;
    }
    .xbtn:active{ background:rgba(255,255,255,.08); }

    .panelBody{
      flex:1;
      display:flex;
      flex-direction:column;
      gap:10px;
      padding:12px;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
      touch-action:auto;
    }

    textarea.mono, input.mono{
      width:100%;
      border-radius:14px;
      border:2px solid rgba(255,255,255,.15);
      background:#121212;
      color:#eaeaea;
      padding:10px;
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      outline:none;
      touch-action:auto !important;
      user-select:text !important;
      -webkit-user-select:text !important;
      -webkit-touch-callout:default !important;
    }
    textarea.mono{ min-height:200px; resize:none; }
    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .kv{
      display:grid;
      grid-template-columns: 1fr;
      gap:8px;
      width:100%;
    }
    .label{
      color:rgba(255,255,255,.8);
      font-size:12px;
      line-height:1.25;
    }
    .small{
      color:rgba(255,255,255,.65);
      font-size:11px;
      line-height:1.25;
    }

    #exportCode{
      min-height:240px;
      height:100%;
    }
    #previewWrap{
      border:2px solid rgba(255,255,255,.12);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    #preview{
      height:160px;
      width:100%;
      border:0;
      background:#fff;
      display:block;
    }

    /* Toast + Fatal */
    #toast{
      position:absolute;
      left:50%;
      bottom:calc(14px + var(--sa-bottom));
      transform:translateX(-50%) translateY(20px);
      background:rgba(0,0,0,.78);
      border:2px solid rgba(255,255,255,.15);
      padding:10px 12px;
      border-radius:14px;
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#fff;
      opacity:0;
      pointer-events:none;
      transition:opacity .16s ease, transform .16s ease;
      z-index:999;
      max-width:86vw;
      text-align:center;
      white-space:pre-line;
    }
    #toast.on{ opacity:1; transform:translateX(-50%) translateY(0); }

    #fatal{
      position:absolute; inset:0;
      display:none;
      align-items:flex-start; justify-content:flex-start;
      padding:16px;
      background:#0b0b0b;
      color:#fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      z-index:999;
      user-select:text;
      -webkit-user-select:text;
      touch-action:auto;
      overflow:auto;
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>

  <div id="ui">
    <div id="scrim"></div>

    <button id="btn-add" class="btn" type="button" aria-label="Add block">Ôºã</button>
    <button id="btn-del" class="btn" type="button" aria-label="Delete selected">üóë</button>
    <button id="btn-help" class="btn" type="button" aria-label="Help">‚ùî</button>
    <button id="btn-export" class="btn" type="button" aria-label="Export / Copy">üì§</button>
    <button id="btn-import" class="btn" type="button" aria-label="Import HTML">üì•</button>
    <button id="btn-edit" class="btn" type="button" aria-label="Edit selected">‚úé</button>

    <div id="picker" aria-label="Block type picker">
      <div style="font-weight:900; letter-spacing:.6px; margin:0 0 10px 2px; color:rgba(255,255,255,.85); font-size:12px;">
        ADD BLOCK (HTML TAG)
      </div>

      <div id="pickerTabs">
        <button class="tab on" data-tab="struct">STRUCT</button>
        <button class="tab" data-tab="text">TEXT</button>
        <button class="tab" data-tab="media">MEDIA</button>
        <button class="tab" data-tab="form">FORM</button>
        <button class="tab" data-tab="code">CODE</button>
      </div>

      <div class="pick-grid on" data-grid="struct">
        <button class="pill" data-tag="header">HEADER</button>
        <button class="pill" data-tag="nav">NAV</button>
        <button class="pill" data-tag="main">MAIN</button>
        <button class="pill" data-tag="section">SECTION</button>
        <button class="pill" data-tag="article">ARTICLE</button>
        <button class="pill" data-tag="aside">ASIDE</button>
        <button class="pill" data-tag="footer">FOOTER</button>
        <button class="pill" data-tag="div">DIV</button>
        <button class="pill" data-tag="ul">UL</button>
        <button class="pill" data-tag="li">LI</button>
      </div>

      <div class="pick-grid" data-grid="text">
        <button class="pill" data-tag="h1">H1</button>
        <button class="pill" data-tag="h2">H2</button>
        <button class="pill" data-tag="h3">H3</button>
        <button class="pill" data-tag="p">P</button>
        <button class="pill" data-tag="span">SPAN</button>
        <button class="pill" data-tag="a">A</button>
        <button class="pill" data-tag="strong">STRONG</button>
        <button class="pill" data-tag="em">EM</button>
        <button class="pill" data-tag="code">CODE</button>
      </div>

      <div class="pick-grid" data-grid="media">
        <button class="pill" data-tag="img">IMG</button>
        <button class="pill" data-tag="video">VIDEO</button>
        <button class="pill" data-tag="audio">AUDIO</button>
        <button class="pill" data-tag="canvas">CANVAS</button>
        <button class="pill" data-tag="svg">SVG</button>
        <button class="pill" data-tag="iframe">IFRAME</button>
      </div>

      <div class="pick-grid" data-grid="form">
        <button class="pill" data-tag="button">BUTTON</button>
        <button class="pill" data-tag="input">INPUT</button>
        <button class="pill" data-tag="textarea">TEXTAREA</button>
        <button class="pill" data-tag="select">SELECT</button>
        <button class="pill" data-tag="label">LABEL</button>
        <button class="pill" data-tag="form">FORM</button>
      </div>

      <div class="pick-grid" data-grid="code">
        <button class="pill" data-tag="style" data-domain="head">STYLE</button>
        <button class="pill" data-tag="script" data-domain="bodytail">SCRIPT</button>
        <button class="pill" data-tag="link" data-domain="head">LINK</button>
        <button class="pill" data-tag="meta" data-domain="head">META</button>
      </div>

      <div style="margin-top:10px; color:rgba(255,255,255,.65); font-size:11px; line-height:1.25;">
        Drag cube: snapped grid (no overlap). Same cell stacks (Z-index in export).<br>
        Drag empty: orbit. Pinch: zoom. Two-finger drag: pan.
      </div>
    </div>

    <div id="hint"></div>

    <!-- EXPORT PANEL -->
    <div id="panelExport" class="panel" role="dialog" aria-label="Export" aria-hidden="true" style="border-top-color: var(--accent);">
      <div class="panelHead">
        <div class="panelTitle">
          <b>EXPORT + COPY (ROUNDTRIP)</b>
          <span id="exportSub">mode=ROUNDTRIP ‚Ä¢ scope=ALL ‚Ä¢ scripts=SAFE</span>
        </div>
        <div class="panelTools">
          <button id="btn-copy" class="toolbtn" type="button">COPY</button>
          <button id="btn-select" class="toolbtn" type="button">SELECT</button>
          <button id="btn-mode" class="toolbtn on" type="button">MODE: ROUNDTRIP</button>
          <button id="btn-scope" class="toolbtn" type="button">SCOPE: ALL</button>
          <button id="btn-scripts" class="toolbtn" type="button">PREVIEW: SAFE</button>
          <button id="btn-rebuild" class="toolbtn" type="button">REBUILD</button>
          <button id="btn-export-close" class="xbtn" type="button" aria-label="Close">‚úï</button>
        </div>
      </div>
      <div class="panelBody">
        <div class="small">
          Paste this app‚Äôs own HTML into Import ‚Üí Visualize ‚Üí move blocks ‚Üí Export updates instantly ‚Üí COPY.
        </div>

        <textarea id="exportCode" class="mono" spellcheck="false"></textarea>

        <div id="previewWrap">
          <!-- SAFE preview by default: no scripts -->
          <iframe id="preview" sandbox="allow-same-origin" title="Preview"></iframe>
        </div>
      </div>
    </div>

    <!-- IMPORT PANEL -->
    <div id="panelImport" class="panel" role="dialog" aria-label="Import" aria-hidden="true">
      <div class="panelHead">
        <div class="panelTitle">
          <b>IMPORT HTML ‚Üí BLOCKS (ROUNDTRIP)</b>
          <span id="importSub">source=EMPTY</span>
        </div>
        <div class="panelTools">
          <button id="btn-paste" class="toolbtn on" type="button">PASTE</button>
          <button id="btn-visualize" class="toolbtn on" type="button">VISUALIZE</button>
          <button id="btn-depth" class="toolbtn" type="button">DEPTH: TOP</button>
          <button id="btn-clear" class="toolbtn" type="button">CLEAR</button>
          <button id="btn-import-close" class="xbtn" type="button" aria-label="Close">‚úï</button>
        </div>
      </div>
      <div class="panelBody">
        <div class="label">Paste HTML (fragment or full document). This tool preserves HEAD + BODYTAIL blocks and exports a runnable single-file HTML.</div>
        <textarea id="importText" class="mono" spellcheck="false" placeholder="Paste HTML here... (try pasting THIS APP code)"></textarea>
        <div id="importStats" class="small"></div>
      </div>
    </div>

    <!-- EDIT/INSPECTOR PANEL -->
    <div id="panelEdit" class="panel" role="dialog" aria-label="Edit Selected" aria-hidden="true" style="border-top-color: #7cff6a;">
      <div class="panelHead">
        <div class="panelTitle">
          <b>EDIT SELECTED BLOCK</b>
          <span id="editSub">no selection</span>
        </div>
        <div class="panelTools">
          <button id="btn-applyEdit" class="toolbtn on" type="button">APPLY</button>
          <button id="btn-rawEdit" class="toolbtn" type="button">RAW: OFF</button>
          <button id="btn-edit-close" class="xbtn" type="button" aria-label="Close">‚úï</button>
        </div>
      </div>
      <div class="panelBody">
        <div class="kv">
          <div class="label">Tag (editable). For code/head blocks, use STYLE/SCRIPT/LINK/META.</div>
          <input id="editTag" class="mono" type="text" spellcheck="false" placeholder="div" />
          <div class="label">Label/content (used for text tags; IMG uses src; A uses href; INPUT uses value/placeholder)</div>
          <input id="editContent" class="mono" type="text" spellcheck="false" placeholder="Hello" />
          <div class="label">Attributes (one per line). Example: id=&quot;hero&quot; class=&quot;card&quot; style=&quot;color:red&quot; src=&quot;...&quot; href=&quot;...&quot;</div>
          <textarea id="editAttrs" class="mono" spellcheck="false" style="min-height:140px;" placeholder='id="x"
class="y"
style="padding:10px"'></textarea>

          <div class="label">Raw outerHTML (optional). Turn RAW on to edit exact element markup.</div>
          <textarea id="editRaw" class="mono" spellcheck="false" style="min-height:180px; display:none;" placeholder="<div>...</div>"></textarea>

          <div class="small">
            Notes:
            ‚Ä¢ Moving blocks changes layout in exported HTML (ROUNDTRIP mode) via injected CSS grid positions.<br>
            ‚Ä¢ HEAD blocks export into &lt;head&gt;. BODYTAIL blocks export at end of &lt;body&gt;.
          </div>
        </div>
      </div>
    </div>

    <div id="toast"></div>
  </div>

  <div id="fatal"></div>

  <script>
    (() => {
      const fatalEl = document.getElementById('fatal');
      const toastEl = document.getElementById('toast');
      const toast = (msg) => {
        toastEl.textContent = String(msg);
        toastEl.classList.add("on");
        clearTimeout(toastEl._t);
        toastEl._t = setTimeout(()=>toastEl.classList.remove("on"), 1400);
      };
      const die = (msg) => {
        fatalEl.style.display = "flex";
        fatalEl.textContent = msg;
        throw new Error(msg);
      };
      window.addEventListener('error', (e)=>{ die("[JS ERROR]\n" + (e.error && e.error.stack ? e.error.stack : e.message)); });
      window.addEventListener('unhandledrejection', (e)=>{ die("[PROMISE REJECT]\n" + (e.reason && e.reason.stack ? e.reason.stack : String(e.reason))); });

      const canvas = document.getElementById('gl');
      const hud = document.getElementById('hud');
      const h2d = hud.getContext('2d');
      const gl = canvas.getContext('webgl', { antialias:true, alpha:false, depth:true, premultipliedAlpha:false });
      if (!gl) die("WebGL not available.");

      // UI refs
      const btnAdd = document.getElementById('btn-add');
      const btnDel = document.getElementById('btn-del');
      const btnHelp = document.getElementById('btn-help');
      const btnExport = document.getElementById('btn-export');
      const btnImport = document.getElementById('btn-import');
      const btnEdit = document.getElementById('btn-edit');

      const picker = document.getElementById('picker');
      const hint = document.getElementById('hint');
      const scrim = document.getElementById('scrim');

      const panelExport = document.getElementById('panelExport');
      const panelImport = document.getElementById('panelImport');
      const panelEdit = document.getElementById('panelEdit');

      const btnExportClose = document.getElementById('btn-export-close');
      const btnImportClose = document.getElementById('btn-import-close');
      const btnEditClose = document.getElementById('btn-edit-close');

      const exportSub = document.getElementById('exportSub');
      const exportCode = document.getElementById('exportCode');
      const preview = document.getElementById('preview');

      const btnCopy = document.getElementById('btn-copy');
      const btnSelect = document.getElementById('btn-select');
      const btnMode = document.getElementById('btn-mode');
      const btnScope = document.getElementById('btn-scope');
      const btnScripts = document.getElementById('btn-scripts');
      const btnRebuild = document.getElementById('btn-rebuild');

      const importSub = document.getElementById('importSub');
      const importText = document.getElementById('importText');
      const importStats = document.getElementById('importStats');
      const btnPaste = document.getElementById('btn-paste');
      const btnVisualize = document.getElementById('btn-visualize');
      const btnDepth = document.getElementById('btn-depth');
      const btnClear = document.getElementById('btn-clear');

      const editSub = document.getElementById('editSub');
      const editTag = document.getElementById('editTag');
      const editContent = document.getElementById('editContent');
      const editAttrs = document.getElementById('editAttrs');
      const editRaw = document.getElementById('editRaw');
      const btnApplyEdit = document.getElementById('btn-applyEdit');
      const btnRawEdit = document.getElementById('btn-rawEdit');

      // ---------- DPI resize ----------
      const DPR = () => Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      function resize(){
        const dpr = DPR();
        const w = Math.floor(innerWidth * dpr);
        const h = Math.floor(innerHeight * dpr);
        if (canvas.width !== w || canvas.height !== h){
          canvas.width = w; canvas.height = h;
          canvas.style.width = innerWidth + "px";
          canvas.style.height = innerHeight + "px";
          gl.viewport(0,0,w,h);
        }
        if (hud.width !== w || hud.height !== h){
          hud.width = w; hud.height = h;
          hud.style.width = innerWidth + "px";
          hud.style.height = innerHeight + "px";
        }
      }
      addEventListener('resize', resize, { passive:true });
      resize();

      // ---------- vec3 ----------
      const v3=(x=0,y=0,z=0)=>({x,y,z});
      const add=(a,b)=>v3(a.x+b.x,a.y+b.y,a.z+b.z);
      const sub=(a,b)=>v3(a.x-b.x,a.y-b.y,a.z-b.z);
      const mul=(a,s)=>v3(a.x*s,a.y*s,a.z*s);
      const cross=(a,b)=>v3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);
      const len=(a)=>Math.hypot(a.x,a.y,a.z);
      const norm=(a)=>{ const L=len(a)||1; return v3(a.x/L,a.y/L,a.z/L); };
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

      // ---------- mat4 (COLUMN-MAJOR) ----------
      const m4 = {
        multiply(a,b){
          const o = new Float32Array(16);
          const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
          const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
          const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
          const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

          const b00=b[0],b01=b[1],b02=b[2],b03=b[3];
          const b10=b[4],b11=b[5],b12=b[6],b13=b[7];
          const b20=b[8],b21=b[9],b22=b[10],b23=b[11];
          const b30=b[12],b31=b[13],b32=b[14],b33=b[15];

          o[0]=a00*b00 + a10*b01 + a20*b02 + a30*b03;
          o[1]=a01*b00 + a11*b01 + a21*b02 + a31*b03;
          o[2]=a02*b00 + a12*b01 + a22*b02 + a32*b03;
          o[3]=a03*b00 + a13*b01 + a23*b02 + a33*b03;

          o[4]=a00*b10 + a10*b11 + a20*b12 + a30*b13;
          o[5]=a01*b10 + a11*b11 + a21*b12 + a31*b13;
          o[6]=a02*b10 + a12*b11 + a22*b12 + a32*b13;
          o[7]=a03*b10 + a13*b11 + a23*b12 + a33*b13;

          o[8]=a00*b20 + a10*b21 + a20*b22 + a30*b23;
          o[9]=a01*b20 + a11*b21 + a21*b22 + a31*b23;
          o[10]=a02*b20 + a12*b21 + a22*b22 + a32*b23;
          o[11]=a03*b20 + a13*b21 + a23*b22 + a33*b23;

          o[12]=a00*b30 + a10*b31 + a20*b32 + a30*b33;
          o[13]=a01*b30 + a11*b31 + a21*b32 + a31*b33;
          o[14]=a02*b30 + a12*b31 + a22*b32 + a32*b33;
          o[15]=a03*b30 + a13*b31 + a23*b32 + a33*b33;
          return o;
        },
        perspective(fovy, aspect, near, far){
          const f = 1.0 / Math.tan(fovy / 2);
          const nf = 1 / (near - far);
          const o = new Float32Array(16);
          o[0] = f / aspect;
          o[5] = f;
          o[10] = (far + near) * nf;
          o[11] = -1;
          o[14] = (2 * far * near) * nf;
          return o;
        },
        lookAt(eye, center, up){
          const o = new Float32Array(16);
          let z0 = eye.x - center.x, z1 = eye.y - center.y, z2 = eye.z - center.z;
          let L = Math.hypot(z0,z1,z2);
          if (L === 0) { z2 = 1; }
          else { z0/=L; z1/=L; z2/=L; }

          let x0 = up.y * z2 - up.z * z1;
          let x1 = up.z * z0 - up.x * z2;
          let x2 = up.x * z1 - up.y * z0;
          L = Math.hypot(x0,x1,x2);
          if (L === 0){ x0=0; x1=0; x2=0; }
          else { x0/=L; x1/=L; x2/=L; }

          let y0 = z1 * x2 - z2 * x1;
          let y1 = z2 * x0 - z0 * x2;
          let y2 = z0 * x1 - z1 * x0;

          o[0]=x0; o[1]=y0; o[2]=z0; o[3]=0;
          o[4]=x1; o[5]=y1; o[6]=z1; o[7]=0;
          o[8]=x2; o[9]=y2; o[10]=z2; o[11]=0;
          o[12]=-(x0*eye.x + x1*eye.y + x2*eye.z);
          o[13]=-(y0*eye.x + y1*eye.y + y2*eye.z);
          o[14]=-(z0*eye.x + z1*eye.y + z2*eye.z);
          o[15]=1;
          return o;
        },
        invert(a){
          const o = new Float32Array(16);
          const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
          const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
          const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
          const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;

          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) return null;
          det = 1.0 / det;

          o[0] = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
          o[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
          o[2] = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
          o[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
          o[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
          o[5] = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
          o[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
          o[7] = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
          o[8] = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
          o[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
          o[10]= ( a30 * b04 - a31 * b02 + a33 * b00) * det;
          o[11]= (-a20 * b04 + a21 * b02 - a23 * b00) * det;
          o[12]= (-a10 * b09 + a11 * b07 - a12 * b06) * det;
          o[13]= ( a00 * b09 - a01 * b07 + a02 * b06) * det;
          o[14]= (-a30 * b03 + a31 * b01 - a32 * b00) * det;
          o[15]= ( a20 * b03 - a21 * b01 + a22 * b00) * det;
          return o;
        }
      };

      function unproject(nx, ny, nz, invVP){
        const x=nx, y=ny, z=nz, w=1;
        const ox = invVP[0]*x + invVP[4]*y + invVP[8]*z + invVP[12]*w;
        const oy = invVP[1]*x + invVP[5]*y + invVP[9]*z + invVP[13]*w;
        const oz = invVP[2]*x + invVP[6]*y + invVP[10]*z + invVP[14]*w;
        const ow = invVP[3]*x + invVP[7]*y + invVP[11]*z + invVP[15]*w;
        if (ow === 0) return null;
        return v3(ox/ow, oy/ow, oz/ow);
      }

      // ---------- Shaders ----------
      function compile(type, src){
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
          const e = gl.getShaderInfoLog(s) || "unknown";
          gl.deleteShader(s);
          die("Shader compile error:\n" + e);
        }
        return s;
      }
      function link(vs, fs){
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
          const e = gl.getProgramInfoLog(p) || "unknown";
          gl.deleteProgram(p);
          die("Program link error:\n" + e);
        }
        return p;
      }

      const VS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        uniform mat4 u_vp;
        uniform vec3 u_objPos;
        uniform float u_objSize;
        varying vec3 v_nrm;
        void main(){
          vec3 p = a_pos * u_objSize + u_objPos;
          v_nrm = a_nrm;
          gl_Position = u_vp * vec4(p, 1.0);
        }
      `;
      const FS = `
        precision mediump float;
        uniform vec3 u_color;
        uniform vec3 u_lightDir;
        uniform float u_alpha;
        varying vec3 v_nrm;
        void main(){
          float ndl = max(dot(normalize(v_nrm), normalize(u_lightDir)), 0.0);
          float shade = 0.25 + ndl * 0.75;
          gl_FragColor = vec4(u_color * shade, u_alpha);
        }
      `;

      const prog = link(compile(gl.VERTEX_SHADER, VS), compile(gl.FRAGMENT_SHADER, FS));
      gl.useProgram(prog);

      const loc = {
        a_pos: gl.getAttribLocation(prog, "a_pos"),
        a_nrm: gl.getAttribLocation(prog, "a_nrm"),
        u_vp: gl.getUniformLocation(prog, "u_vp"),
        u_objPos: gl.getUniformLocation(prog, "u_objPos"),
        u_objSize: gl.getUniformLocation(prog, "u_objSize"),
        u_color: gl.getUniformLocation(prog, "u_color"),
        u_lightDir: gl.getUniformLocation(prog, "u_lightDir"),
        u_alpha: gl.getUniformLocation(prog, "u_alpha"),
      };

      // ---------- Cube geometry ----------
      const cube = (() => {
        const P=[], N=[];
        function face(nx,ny,nz, ax,ay,az, bx,by,bz, cx,cy,cz, dx,dy,dz){
          const v = [
            ax,ay,az, bx,by,bz, cx,cy,cz,
            ax,ay,az, cx,cy,cz, dx,dy,dz
          ];
          for(let i=0;i<v.length;i+=3){ P.push(v[i],v[i+1],v[i+2]); N.push(nx,ny,nz); }
        }
        face(0,0,1,  -0.5,-0.5,0.5,  0.5,-0.5,0.5,  0.5,0.5,0.5,  -0.5,0.5,0.5);
        face(0,0,-1,  0.5,-0.5,-0.5, -0.5,-0.5,-0.5, -0.5,0.5,-0.5, 0.5,0.5,-0.5);
        face(1,0,0,   0.5,-0.5,0.5,  0.5,-0.5,-0.5,  0.5,0.5,-0.5,  0.5,0.5,0.5);
        face(-1,0,0,  -0.5,-0.5,-0.5, -0.5,-0.5,0.5, -0.5,0.5,0.5, -0.5,0.5,-0.5);
        face(0,1,0,   -0.5,0.5,0.5,  0.5,0.5,0.5,  0.5,0.5,-0.5, -0.5,0.5,-0.5);
        face(0,-1,0,  -0.5,-0.5,-0.5, 0.5,-0.5,-0.5, 0.5,-0.5,0.5, -0.5,-0.5,0.5);
        return { P:new Float32Array(P), N:new Float32Array(N), count:P.length/3 };
      })();

      const vboPos = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
      gl.bufferData(gl.ARRAY_BUFFER, cube.P, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(loc.a_pos);
      gl.vertexAttribPointer(loc.a_pos, 3, gl.FLOAT, false, 0, 0);

      const vboNrm = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboNrm);
      gl.bufferData(gl.ARRAY_BUFFER, cube.N, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(loc.a_nrm);
      gl.vertexAttribPointer(loc.a_nrm, 3, gl.FLOAT, false, 0, 0);

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearColor(0.08,0.08,0.08,1);

      // ---------- Scene / Camera ----------
      const UP = v3(0,1,0);

      const TAG_COLORS = {
        // structure
        header:[0.40,0.85,0.95], nav:[0.35,0.78,0.92], main:[0.38,0.92,0.62], section:[0.32,0.72,0.92],
        article:[0.55,0.82,1.00], aside:[0.60,0.70,0.95], footer:[0.42,0.70,0.80], div:[0.78,0.78,0.78],
        ul:[0.75,0.92,0.80], li:[0.65,0.85,0.72],
        // text
        h1:[1.00,0.86,0.82], h2:[1.00,0.78,0.72], h3:[1.00,0.72,0.62],
        p:[0.95,0.95,0.95], span:[0.90,0.90,0.90], a:[0.55,0.85,1.00], strong:[1.00,0.90,0.55], em:[0.95,0.75,1.00], code:[0.70,1.00,0.70],
        // media
        img:[0.92,0.84,0.98], video:[0.90,0.60,0.95], audio:[0.65,0.85,0.95], canvas:[0.85,0.85,0.60], svg:[0.95,0.80,0.60], iframe:[0.75,0.75,1.00],
        // form
        button:[0.95,0.70,0.45], input:[0.85,0.95,0.55], textarea:[0.70,0.95,0.70], select:[0.55,0.95,0.95], label:[0.92,0.92,0.70], form:[0.75,0.95,0.85],
        // code/head
        style:[0.00,0.70,1.00], script:[1.00,0.55,0.25], link:[0.25,0.85,1.00], meta:[0.55,0.65,0.75],
        // fallback
        other:[0.70,0.92,0.98],
        accent:[0.96,0.50,0.145]
      };

      const SIZE_SCALE = {
        h1:1.18, h2:1.12, h3:1.06,
        header:1.06, nav:1.04, main:1.08, section:1.02, article:1.02, aside:1.00, footer:1.00,
        img:1.12, video:1.14, iframe:1.14, canvas:1.10, svg:1.08,
        button:1.02, input:1.00, textarea:1.06, select:1.02, form:1.06,
        script:0.95, style:0.95, link:0.92, meta:0.92
      };

      const cam = {
        target: v3(0, 0, -140),
        yaw: 0.85,
        pitch: 0.60,
        dist: 900,
        fov: 70*Math.PI/180
      };

      const cubeSize = 70;
      const half = cubeSize * 0.5;
      const groundY = half;

      // "Lanes" in world space for non-visual blocks
      const lanes = {
        head: { x0:-700, z0: 480, cols: 10 },
        body: { x0:-700, z0:-140, cols: 12 },
        bodytail: { x0:-700, z0: 260, cols: 10 }
      };

      // Grid / stacking (no overlap)
      const GRID = { cell: cubeSize, yStep: cubeSize, maxSpiral: 30 };
      const snap = (v, s)=> Math.round(v / s) * s;
      const cellKey = (x,z)=> `${snap(x,GRID.cell)}|${snap(z,GRID.cell)}`;

      function stackLevelAt(key, ignoreId){
        let n = 0;
        for(const b of state.blocks){
          if(ignoreId && b.id === ignoreId) continue;
          if(cellKey(b.pos.x,b.pos.z) === key) n++;
        }
        return n;
      }

      function placeOnGrid(desiredX, desiredZ, idForIgnore, allowStack=true){
        const gx = snap(desiredX, GRID.cell);
        const gz = snap(desiredZ, GRID.cell);
        const key = `${gx}|${gz}`;
        if(allowStack){
          const level = stackLevelAt(key, idForIgnore);
          return { x:gx, z:gz, y:groundY + level*GRID.yStep };
        }
        for(let r=0; r<=GRID.maxSpiral; r++){
          for(let dz=-r; dz<=r; dz++){
            for(let dx=-r; dx<=r; dx++){
              if(Math.abs(dx)!==r && Math.abs(dz)!==r) continue;
              const x = gx + dx*GRID.cell;
              const z = gz + dz*GRID.cell;
              const k = `${x}|${z}`;
              if(stackLevelAt(k, idForIgnore) === 0){
                return { x, z, y:groundY };
              }
            }
          }
        }
        const level = stackLevelAt(key, idForIgnore);
        return { x:gx, z:gz, y:groundY + level*GRID.yStep };
      }

      function normalizeStacks(){
        // rebuild stack y levels per snapped cell for VISUAL blocks only
        const groups = new Map();
        for(const b of state.blocks){
          if(!b.visual) continue;
          const x = snap(b.pos.x, GRID.cell);
          const z = snap(b.pos.z, GRID.cell);
          const k = `${x}|${z}`;
          if(!groups.has(k)) groups.set(k, []);
          groups.get(k).push(b);
        }
        for(const [k, arr] of groups){
          arr.sort((a,b)=>a._stackOrder - b._stackOrder);
          const [xStr,zStr] = k.split("|");
          const x = Number(xStr), z = Number(zStr);
          for(let i=0;i<arr.length;i++){
            arr[i].pos.x = x;
            arr[i].pos.z = z;
            arr[i].pos.y = groundY + i*GRID.yStep;
          }
        }
      }

      function rid(){
        return (crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2));
      }

      function cameraEye(){
        const cp=Math.cos(cam.pitch), sp=Math.sin(cam.pitch);
        const cy=Math.cos(cam.yaw), sy=Math.sin(cam.yaw);
        const dir = v3(sy*cp, sp, cy*cp);
        return add(cam.target, mul(dir, cam.dist));
      }

      function getVP(){
        const aspect = canvas.width / canvas.height;
        const proj = m4.perspective(cam.fov, aspect, 0.1, 6000.0);
        const eye = cameraEye();
        const view = m4.lookAt(eye, cam.target, UP);
        const vp = m4.multiply(proj, view);
        return { vp, eye };
      }

      function rayFromScreen(clientX, clientY){
        const nx = (clientX / innerWidth) * 2 - 1;
        const ny = 1 - (clientY / innerHeight) * 2;
        const { vp, eye } = getVP();
        const invVP = m4.invert(vp);
        if(!invVP) return null;

        const near = unproject(nx, ny, -1, invVP);
        const far  = unproject(nx, ny,  1, invVP);
        if(!near || !far) return null;

        const dir = norm(sub(far, near));
        return { o: eye, d: dir };
      }

      function intersectPlaneY(ray, y){
        const denom = ray.d.y;
        if(Math.abs(denom) < 1e-6) return null;
        const t = (y - ray.o.y) / denom;
        if(t <= 0) return null;
        return add(ray.o, mul(ray.d, t));
      }

      function intersectAABB(ray, min, max){
        let tmin=-Infinity, tmax=Infinity;
        for(const ax of ["x","y","z"]){
          const o = ray.o[ax], d = ray.d[ax];
          if(Math.abs(d) < 1e-8){
            if(o < min[ax] || o > max[ax]) return null;
          } else {
            let t1 = (min[ax] - o)/d;
            let t2 = (max[ax] - o)/d;
            if(t1>t2){ const tmp=t1; t1=t2; t2=tmp; }
            tmin = Math.max(tmin, t1);
            tmax = Math.min(tmax, t2);
            if(tmin>tmax) return null;
          }
        }
        if(tmax < 0) return null;
        return tmin >= 0 ? tmin : tmax;
      }

      function pickBlock(clientX, clientY){
        const ray = rayFromScreen(clientX, clientY);
        if(!ray) return null;
        let best=null, bestT=Infinity;
        for(const b of state.blocks){
          const p=b.pos;
          const s = cubeSize * (b.sizeScale || 1);
          const hh = (s*0.5);
          const min=v3(p.x-hh, p.y-hh, p.z-hh);
          const max=v3(p.x+hh, p.y+hh, p.z+hh);
          const t = intersectAABB(ray, min, max);
          if(t !== null && t < bestT){ bestT=t; best=b; }
        }
        return best;
      }

      // ---------- Project + Blocks ----------
      const state = {
        blocks: [],
        selected: null,
        dragging: null,
        dragStartGround: null,
        dragStartPos: null,
        pointers: new Map(),
        mode: "none",
        orbitLast: null,
        pinch: null,
        helpOn: false,

        panel: null,               // "export"|"import"|"edit"|null
        historyArmed: false,
        closingViaPop: false,

        // Export settings
        exportMode: "roundtrip",    // "roundtrip" | "semantic"
        exportScope: "all",         // "all" | "visual"
        previewScripts: false,      // safe by default

        // Import settings
        depthMode: "top",           // "top" | "deep"

        // Source preservation
        project: {
          sourceName: "EMPTY",
          headHTML: "",
          bodyTailHTML: "",         // scripts etc appended after stage
          docLang: "en",
          docTitle: "Untitled",
        }
      };

      function isVisualTag(tag){
        tag = (tag||"").toLowerCase();
        return !["script","style","meta","link"].includes(tag);
      }

      function tagColor(tag){
        tag = (tag||"").toLowerCase();
        return TAG_COLORS[tag] || TAG_COLORS.other;
      }

      function tagSizeScale(tag){
        tag = (tag||"").toLowerCase();
        return SIZE_SCALE[tag] || 1.0;
      }

      function escapeHTML(s){
        return String(s)
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }

      function parseAttrsLines(lines){
        const attrs = {};
        const arr = String(lines||"").split(/\n+/).map(s=>s.trim()).filter(Boolean);
        for(const ln of arr){
          // accept: key="v" OR key='v' OR key=v
          const m = ln.match(/^([a-zA-Z_:][-a-zA-Z0-9_:.]*)\s*=\s*(.*)$/);
          if(!m) continue;
          const k = m[1];
          let v = m[2].trim();
          if((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) v = v.slice(1,-1);
          attrs[k] = v;
        }
        return attrs;
      }

      function attrsToLines(attrs){
        const keys = Object.keys(attrs||{});
        keys.sort();
        return keys.map(k => `${k}="${String(attrs[k]).replaceAll('"','&quot;')}"`).join("\n");
      }

      function summarizeForLabel(tag, attrs, content){
        tag = (tag||"div").toLowerCase();
        const id = attrs && attrs.id ? ("#" + attrs.id) : "";
        const cls = attrs && attrs.class ? ("." + String(attrs.class).trim().split(/\s+/).slice(0,2).join(".")) : "";
        const hint = (id || cls) ? (id + cls) : "";
        if(tag === "img") return (attrs && attrs.src ? ("img " + String(attrs.src).slice(0,28)) : "img");
        if(tag === "a") return (attrs && attrs.href ? ("a " + String(attrs.href).slice(0,28)) : ("a " + (content||"").slice(0,18)));
        if(tag === "input") return ("input " + (attrs && attrs.type ? attrs.type : "text"));
        if(tag === "meta") return ("meta " + (attrs && (attrs.name||attrs.charset||attrs["http-equiv"]) ? (attrs.name||attrs.charset||attrs["http-equiv"]) : ""));
        if(tag === "link") return ("link " + (attrs && attrs.rel ? attrs.rel : ""));
        if(tag === "script") return ("script " + (attrs && attrs.src ? String(attrs.src).slice(0,28) : ""));
        if(tag === "style") return "style";
        return `${tag}${hint ? " " + hint : ""}`;
      }

      function makeBlock({tag="div", domain="body", content="", attrs={}, outerHTML=""}){
        const id = rid();
        const t = String(tag||"div").toLowerCase();
        const visual = (domain === "body") && isVisualTag(t);
        const sizeScale = tagSizeScale(t);
        const label = summarizeForLabel(t, attrs, content);

        // domain placement
        let pos;
        if(domain === "head"){
          // place in head lane (non-visual)
          const i = state.blocks.filter(b=>b.domain==="head").length;
          const col = i % lanes.head.cols;
          const row = Math.floor(i / lanes.head.cols);
          const x = lanes.head.x0 + col*GRID.cell;
          const z = lanes.head.z0 + row*GRID.cell;
          pos = v3(x, groundY, z);
        } else if(domain === "bodytail"){
          const i = state.blocks.filter(b=>b.domain==="bodytail").length;
          const col = i % lanes.bodytail.cols;
          const row = Math.floor(i / lanes.bodytail.cols);
          const x = lanes.bodytail.x0 + col*GRID.cell;
          const z = lanes.bodytail.z0 + row*GRID.cell;
          pos = v3(x, groundY, z);
        } else {
          // body (visual)
          const desiredX = cam.target.x + (Math.random()*140-70);
          const desiredZ = cam.target.z + 120 + (Math.random()*80-40);
          const p = placeOnGrid(desiredX, desiredZ, id, true);
          pos = v3(p.x,p.y,p.z);
        }

        const b = {
          id,
          tag: t,
          domain,
          visual,
          sizeScale,
          color: tagColor(t),
          label,
          content: String(content||""),
          attrs: {...attrs},
          outerHTML: String(outerHTML||""),

          pos,
          _stackOrder: 0, // for stable stacking per cell
        };
        return b;
      }

      function addBlock(tag, domainOverride){
        const t = String(tag||"div").toLowerCase();
        const domain = domainOverride ? domainOverride : (["meta","link","style"].includes(t) ? "head" : (t==="script" ? "bodytail" : "body"));

        let content = "";
        let attrs = {};
        let outerHTML = "";

        if(t==="h1") content = "Heading";
        else if(t==="p") content = "Paragraph text";
        else if(t==="a"){ content = "Link"; attrs.href = "#"; }
        else if(t==="img"){ attrs.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(`<svg xmlns="http://www.w3.org/2000/svg" width="240" height="120"><rect width="100%" height="100%" fill="#ddd"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#333" font-family="Arial" font-size="18">IMG</text></svg>`); }
        else if(t==="button") content = "Button";
        else if(t==="input"){ attrs.type="text"; attrs.placeholder="Type..."; }
        else if(t==="textarea") content = "Textarea";
        else if(t==="style") content = "/* css */";
        else if(t==="script") content = "// js";
        else if(t==="meta"){ attrs.charset="utf-8"; }
        else if(t==="link"){ attrs.rel="stylesheet"; attrs.href="styles.css"; }
        else content = (["div","section","article","header","footer","main","aside","nav","ul","li","form","label","span","strong","em","code"].includes(t) ? t.toUpperCase() : "");

        // Minimal outerHTML for roundtrip (user can edit in inspector)
        if(t==="img"){
          outerHTML = `<img src="${escapeHTML(attrs.src)}" alt="">`;
        } else if(t==="input"){
          outerHTML = `<input type="${escapeHTML(attrs.type)}" placeholder="${escapeHTML(attrs.placeholder||"")}" value="${escapeHTML(attrs.value||"")}">`;
        } else if(t==="meta"){
          outerHTML = attrs.charset ? `<meta charset="${escapeHTML(attrs.charset)}">` : `<meta name="viewport" content="width=device-width,initial-scale=1">`;
        } else if(t==="link"){
          outerHTML = `<link rel="${escapeHTML(attrs.rel||"stylesheet")}" href="${escapeHTML(attrs.href||"")}">`;
        } else if(t==="style"){
          outerHTML = `<style>\n${escapeHTML(content)}\n</style>`;
        } else if(t==="script"){
          outerHTML = `<script>\n${escapeHTML(content)}\n</script>`;
        } else {
          outerHTML = `<${t}>${escapeHTML(content)}</${t}>`;
        }

        const b = makeBlock({tag:t, domain, content, attrs, outerHTML});
        if(b.visual){
          // stable stack order within its snapped cell
          const k = cellKey(b.pos.x,b.pos.z);
          b._stackOrder = stackLevelAt(k, null);
        }
        state.blocks.push(b);
        state.selected = b.id;
        normalizeStacks();
        rebuildExport(true);
      }

      function deleteSelected(){
        if(!state.selected) return;
        const i = state.blocks.findIndex(b => b.id === state.selected);
        if(i >= 0) state.blocks.splice(i,1);
        state.selected = null;
        normalizeStacks();
        rebuildExport(true);
      }

      // ---------- Panels / Navigation (fixed) ----------
      function setPicker(open){ picker.classList.toggle("open", open); }
      function setScrim(open){ scrim.classList.toggle("open", open); }

      function closePanelFromPop(){
        state.closingViaPop = true;
        state.panel = null;
        panelExport.classList.remove("open"); panelExport.setAttribute("aria-hidden","true");
        panelImport.classList.remove("open"); panelImport.setAttribute("aria-hidden","true");
        panelEdit.classList.remove("open");   panelEdit.setAttribute("aria-hidden","true");
        setScrim(false);
        setPicker(false);
        state.historyArmed = false;
        setTimeout(()=>{ state.closingViaPop = false; }, 0);
      }

      function openPanel(name){
        // only one panel at a time
        state.panel = name;
        panelExport.classList.toggle("open", name==="export");
        panelExport.setAttribute("aria-hidden", name==="export" ? "false" : "true");
        panelImport.classList.toggle("open", name==="import");
        panelImport.setAttribute("aria-hidden", name==="import" ? "false" : "true");
        panelEdit.classList.toggle("open", name==="edit");
        panelEdit.setAttribute("aria-hidden", name==="edit" ? "false" : "true");
        setScrim(true);
        setPicker(false);

        // Arm browser back ONLY once per open cycle (Android back closes the panel reliably)
        if(!state.historyArmed){
          history.pushState({ s420panel:true }, "");
          state.historyArmed = true;
        }

        // Focus
        if(name==="export"){
          rebuildExport(true);
          setTimeout(()=>{ exportCode.focus(); }, 50);
        } else if(name==="import"){
          setTimeout(()=>{ importText.focus(); }, 50);
        } else if(name==="edit"){
          loadSelectedIntoEditor();
          setTimeout(()=>{ editTag.focus(); }, 50);
        }
      }

      function closePanel(){
        if(!state.panel) return;
        // If armed, trigger browser back to keep hardware-back consistent
        if(state.historyArmed && !state.closingViaPop){
          history.back(); // popstate will closePanelFromPop()
          return;
        }
        // fallback
        closePanelFromPop();
      }

      window.addEventListener("popstate", (e)=>{
        if(state.historyArmed && state.panel){
          closePanelFromPop();
        }
      });

      scrim.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        closePanel();
      }, {passive:false});

      // ---------- Picker tabs ----------
      picker.addEventListener("pointerdown",(e)=>{
        const tab = e.target.closest(".tab");
        if(tab){
          e.preventDefault(); e.stopPropagation();
          const t = tab.dataset.tab;
          for(const b of picker.querySelectorAll(".tab")) b.classList.toggle("on", b.dataset.tab===t);
          for(const g of picker.querySelectorAll(".pick-grid")) g.classList.toggle("on", g.dataset.grid===t);
          return;
        }
        const pill = e.target.closest(".pill");
        if(pill){
          e.preventDefault(); e.stopPropagation();
          const tag = pill.dataset.tag;
          const dom = pill.dataset.domain;
          setPicker(false);
          addBlock(tag, dom);
        }
      }, {passive:false});

      // ---------- Help ----------
      hint.textContent =
`Controls:
‚Ä¢ Drag cube: snapped grid (no overlap)
‚Ä¢ Same cell = stack (exports as z-index overlap)
‚Ä¢ Drag empty: orbit camera
‚Ä¢ Pinch: zoom
‚Ä¢ Two-finger drag: pan target
Panels:
‚Ä¢ Scrim tap or ‚úï closes panels
‚Ä¢ Android Back closes panels (fixed)`;

      // ---------- Buttons ----------
      btnAdd.addEventListener("pointerdown", (e)=>{ e.preventDefault(); e.stopPropagation(); setPicker(!picker.classList.contains("open")); }, {passive:false});
      btnDel.addEventListener("pointerdown", (e)=>{ e.preventDefault(); e.stopPropagation(); deleteSelected(); }, {passive:false});
      btnHelp.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); state.helpOn=!state.helpOn; hint.style.display=state.helpOn?"block":"none"; }, {passive:false});
      btnExport.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); openPanel("export"); }, {passive:false});
      btnImport.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); openPanel("import"); }, {passive:false});
      btnEdit.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); openPanel("edit"); }, {passive:false});

      btnExportClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanel(); }, {passive:false});
      btnImportClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanel(); }, {passive:false});
      btnEditClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanel(); }, {passive:false});

      // ---------- Clipboard copy (robust) ----------
      async function copyTextToClipboard(text){
        const t = String(text || "");
        try{
          if(navigator.clipboard && navigator.clipboard.writeText){
            await navigator.clipboard.writeText(t);
            return true;
          }
        } catch(_) {}
        try{
          const ta = document.createElement("textarea");
          ta.value = t;
          ta.setAttribute("readonly","");
          ta.style.position="fixed";
          ta.style.left="-9999px";
          ta.style.top="0";
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          const ok = document.execCommand && document.execCommand("copy");
          document.body.removeChild(ta);
          return !!ok;
        } catch(_) { return false; }
      }

      btnCopy.addEventListener("pointerdown", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        rebuildExport(true);
        const ok = await copyTextToClipboard(exportCode.value);
        toast(ok ? "Copied export to clipboard." : "Copy blocked. Use SELECT then long-press ‚Üí Copy.");
      }, {passive:false});

      btnSelect.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        exportCode.focus();
        exportCode.select();
        toast("Selected. Long-press ‚Üí Copy.");
      }, {passive:false});

      btnMode.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.exportMode = (state.exportMode === "roundtrip") ? "semantic" : "roundtrip";
        btnMode.textContent = "MODE: " + (state.exportMode === "roundtrip" ? "ROUNDTRIP" : "SEMANTIC");
        btnMode.classList.toggle("on", state.exportMode === "roundtrip");
        rebuildExport(true);
        toast("Mode: " + state.exportMode.toUpperCase());
      }, {passive:false});

      btnScope.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.exportScope = (state.exportScope === "all") ? "visual" : "all";
        btnScope.textContent = "SCOPE: " + (state.exportScope === "all" ? "ALL" : "VISUAL");
        rebuildExport(true);
        toast("Scope: " + state.exportScope.toUpperCase());
      }, {passive:false});

      btnScripts.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.previewScripts = !state.previewScripts;
        btnScripts.textContent = "PREVIEW: " + (state.previewScripts ? "LIVE" : "SAFE");
        btnScripts.classList.toggle("on", state.previewScripts);
        rebuildExport(true);
        toast("Preview: " + (state.previewScripts ? "LIVE (scripts allowed)" : "SAFE"));
      }, {passive:false});

      btnRebuild.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        rebuildExport(true);
        toast("Rebuilt export.");
      }, {passive:false});

      // ---------- Import ----------
      function updateImportStats(extra=""){
        const t = importText.value || "";
        importStats.textContent = `chars=${t.length} ‚Ä¢ depth=${state.depthMode.toUpperCase()}` + (extra ? ("\n" + extra) : "");
      }
      importText.addEventListener("input", ()=>updateImportStats(), {passive:true});
      updateImportStats();

      btnClear.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        importText.value = "";
        state.project.sourceName = "EMPTY";
        state.project.headHTML = "";
        state.project.bodyTailHTML = "";
        importSub.textContent = "source=EMPTY";
        updateImportStats("Cleared.");
      }, {passive:false});

      btnDepth.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.depthMode = (state.depthMode === "top") ? "deep" : "top";
        btnDepth.textContent = "DEPTH: " + (state.depthMode === "top" ? "TOP" : "DEEP");
        updateImportStats("Depth changed.");
      }, {passive:false});

      btnPaste.addEventListener("pointerdown", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        try{
          if(navigator.clipboard && navigator.clipboard.readText){
            const t = await navigator.clipboard.readText();
            if(!t){ updateImportStats("Clipboard empty."); return; }
            importText.focus();
            importText.value = t;
            updateImportStats(`Pasted ${t.length} chars.`);
          } else {
            updateImportStats("Clipboard API unavailable. Long-press ‚Üí Paste.");
          }
        } catch(err){
          updateImportStats("Clipboard blocked. Long-press ‚Üí Paste.");
        }
      }, {passive:false});

      function parseHTMLDocument(src){
        const html = String(src || "");
        const doc = new DOMParser().parseFromString(html, "text/html");
        const lang = (doc.documentElement && doc.documentElement.getAttribute("lang")) || "en";
        const title = (doc.querySelector("title") && doc.querySelector("title").textContent) ? doc.querySelector("title").textContent.trim() : "Untitled";
        const headHTML = doc.head ? doc.head.innerHTML : "";
        const body = doc.body;

        // BODYTAIL = scripts that are direct children of body (plus styles if present) that should remain runnable
        const bodyTail = [];
        const bodyVisualCandidates = [];

        const isCodeTag = (el)=> {
          const t = el.tagName.toLowerCase();
          return ["script","style"].includes(t);
        };

        if(body){
          const children = Array.from(body.children || []);
          for(const el of children){
            const t = el.tagName.toLowerCase();
            if(t === "script" || t === "style"){
              bodyTail.push(el.outerHTML);
            } else {
              bodyVisualCandidates.push(el);
            }
          }
        }

        return { doc, lang, title, headHTML, bodyTailHTML: bodyTail.join("\n"), bodyVisualCandidates };
      }

      function elementToBlock(el, domain){
        const tag = el.tagName.toLowerCase();
        const attrs = {};
        for(const a of Array.from(el.attributes || [])){
          attrs[a.name] = a.value;
        }
        // content for label/editor (for non-void tags)
        let content = "";
        if(tag === "img") content = attrs.src || "";
        else if(tag === "a") content = (el.textContent||"").trim().slice(0,220);
        else if(tag === "input") content = attrs.value || "";
        else content = (el.textContent||"").trim().replace(/\s+/g," ").slice(0,220);

        return makeBlock({
          tag,
          domain,
          content,
          attrs,
          outerHTML: el.outerHTML
        });
      }

      function buildBlocksFromImport(src){
        const { doc, lang, title, headHTML, bodyTailHTML, bodyVisualCandidates } = parseHTMLDocument(src);

        state.project.docLang = lang;
        state.project.docTitle = title;
        state.project.headHTML = headHTML || "";
        state.project.bodyTailHTML = bodyTailHTML || "";
        state.project.sourceName = (title && title !== "Untitled") ? title : ("import_" + new Date().toISOString());
        importSub.textContent = `source=${state.project.sourceName}`;

        // Wipe only body-visual blocks; keep existing? user wants paste this app and rebuild clean:
        state.blocks = [];

        // HEAD blocks: represent meta/link/style/script in head (for completeness)
        const headEls = doc.head ? Array.from(doc.head.children || []) : [];
        for(const el of headEls){
          const t = el.tagName.toLowerCase();
          if(!["meta","link","style","script","title","base"].includes(t)) continue;
          // title/base are treated as meta-ish
          const b = elementToBlock(el, "head");
          b.visual = false;
          b.color = tagColor(t);
          b.sizeScale = tagSizeScale(t);
          b.label = summarizeForLabel(t, b.attrs, b.content);
          state.blocks.push(b);
        }

        // BODY visual blocks
        if(state.depthMode === "top"){
          for(const el of bodyVisualCandidates){
            const b = elementToBlock(el, "body");
            state.blocks.push(b);
          }
        } else {
          // DEEP: include descendants (bounded)
          const MAX = 280;
          let n = 0;
          const walk = (el)=>{
            if(n >= MAX) return;
            if(!el || !el.tagName) return;
            const tag = el.tagName.toLowerCase();
            if(tag === "script" || tag === "style") return;
            const b = elementToBlock(el, "body");
            state.blocks.push(b);
            n++;
            for(const ch of Array.from(el.children || [])) walk(ch);
          };
          for(const el of bodyVisualCandidates) walk(el);
        }

        // BODYTAIL scripts/styles: represent as blocks too
        const tailDoc = new DOMParser().parseFromString(`<body>${state.project.bodyTailHTML}</body>`, "text/html");
        const tailEls = tailDoc.body ? Array.from(tailDoc.body.children || []) : [];
        for(const el of tailEls){
          const b = elementToBlock(el, "bodytail");
          b.visual = false;
          b.color = tagColor(b.tag);
          b.sizeScale = tagSizeScale(b.tag);
          b.label = summarizeForLabel(b.tag, b.attrs, b.content);
          state.blocks.push(b);
        }

        // Place VISUAL blocks in a grid near camera target
        const vis = state.blocks.filter(b=>b.domain==="body");
        const cols = 12;
        const startX = snap(cam.target.x - GRID.cell*5, GRID.cell);
        const startZ = snap(cam.target.z - GRID.cell*2, GRID.cell);
        for(let i=0;i<vis.length;i++){
          const b = vis[i];
          const x = startX + (i % cols) * GRID.cell;
          const z = startZ + Math.floor(i / cols) * GRID.cell;
          const p = placeOnGrid(x, z, b.id, true);
          b.pos.x = p.x; b.pos.z = p.z; b.pos.y = p.y;
          b._stackOrder = i; // stable initial order for stacking
          b.visual = true;
          b.color = tagColor(b.tag);
          b.sizeScale = tagSizeScale(b.tag);
          b.label = summarizeForLabel(b.tag, b.attrs, b.content);
        }

        normalizeStacks();
        state.selected = (vis[0] && vis[0].id) ? vis[0].id : (state.blocks[0] ? state.blocks[0].id : null);

        // Focus camera
        focusOnVisual();
        rebuildExport(true);

        return {
          headBlocks: state.blocks.filter(b=>b.domain==="head").length,
          visualBlocks: state.blocks.filter(b=>b.domain==="body").length,
          tailBlocks: state.blocks.filter(b=>b.domain==="bodytail").length,
          title
        };
      }

      function focusOnVisual(){
        const vis = state.blocks.filter(b=>b.domain==="body");
        if(!vis.length) return;
        let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
        for(const b of vis){
          minX=Math.min(minX,b.pos.x); maxX=Math.max(maxX,b.pos.x);
          minZ=Math.min(minZ,b.pos.z); maxZ=Math.max(maxZ,b.pos.z);
        }
        cam.target.x = (minX+maxX)/2;
        cam.target.z = (minZ+maxZ)/2;
        cam.target.y = 0;
        const span = Math.max(maxX-minX, maxZ-minZ);
        cam.dist = clamp(850 + span*1.15, 520, 2600);
      }

      btnVisualize.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        const src = importText.value || "";
        if(!src.trim()){
          updateImportStats("Nothing to visualize.");
          toast("Paste HTML first.");
          return;
        }
        const info = buildBlocksFromImport(src);
        updateImportStats(`Parsed: head=${info.headBlocks}, visual=${info.visualBlocks}, tail=${info.tailBlocks}`);
        toast(`Visualized ${info.visualBlocks} body blocks`);
        // stay in import panel; user can close manually
      }, {passive:false});

      // ---------- Export (ROUNDTRIP) ----------
      function blockToElementHTML(block, gridInfo){
        // Prefer raw outerHTML if present; otherwise synthesize from tag/content/attrs
        const tag = (block.tag||"div").toLowerCase();
        const attrs = block.attrs || {};
        const content = block.content || "";

        // Create a DOM element to safely inject layout styles (without executing scripts here)
        let el;
        try{
          const wrap = new DOMParser().parseFromString(`<body>${block.outerHTML || ""}</body>`, "text/html");
          el = wrap.body && wrap.body.firstElementChild ? wrap.body.firstElementChild : null;
        } catch(_){ el = null; }

        if(!el){
          // synthesize
          const doc = document.implementation.createHTMLDocument("");
          el = doc.createElement(tag);
          for(const k in attrs) el.setAttribute(k, attrs[k]);
          if(tag === "img") {
            if(!el.getAttribute("src")) el.setAttribute("src", content);
          } else if(tag === "input"){
            if(attrs.type) el.setAttribute("type", attrs.type);
            if(attrs.placeholder) el.setAttribute("placeholder", attrs.placeholder);
            if(attrs.value) el.setAttribute("value", attrs.value);
          } else if(tag === "meta" || tag === "link"){
            // void
          } else {
            el.textContent = content;
          }
        }

        // Ensure attrs from editor override
        for(const k in attrs){
          try{ el.setAttribute(k, attrs[k]); } catch(_){}
        }

        // Assign stable id for mapping
        el.setAttribute("data-s420-id", block.id);

        // Layout injection only for VISUAL blocks
        if(block.domain === "body" && block.visual){
          const { col, row, zIndex } = gridInfo(block);
          const prevStyle = el.getAttribute("style") || "";
          const inject = `grid-column:${col};grid-row:${row};z-index:${zIndex};`;
          el.setAttribute("style", (prevStyle ? (prevStyle.trim().replace(/;?$/,";") + inject) : inject));
        }

        return el.outerHTML;
      }

      function computeGridMap(blocks){
        // Map snapped XZ to grid indices (row-major), preserving full bounds
        let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
        for(const b of blocks){
          const x = snap(b.pos.x, GRID.cell);
          const z = snap(b.pos.z, GRID.cell);
          minX=Math.min(minX,x); maxX=Math.max(maxX,x);
          minZ=Math.min(minZ,z); maxZ=Math.max(maxZ,z);
        }
        const cols = Math.max(1, Math.round((maxX-minX)/GRID.cell) + 1);
        const rows = Math.max(1, Math.round((maxZ-minZ)/GRID.cell) + 1);
        return { minX, minZ, cols, rows };
      }

      function semanticExport(){
        const blocks = state.blocks.slice();
        const pick = (state.exportScope === "visual")
          ? blocks.filter(b=>b.domain==="body" && b.visual)
          : blocks;

        if(!pick.length) return { code:"// Export Empty", preview:"" };

        // Simple: list tags as-is (no layout)
        const head = state.project.headHTML || "";
        const bodyTail = state.project.bodyTailHTML || "";

        const bodyEls = pick.filter(b=>b.domain==="body").map(b => b.outerHTML || `<${b.tag}></${b.tag}>`).join("\n");
        const code =
`<!doctype html>
<html lang="${escapeHTML(state.project.docLang||"en")}">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>${escapeHTML(state.project.docTitle||"Untitled")}</title>
${head}
</head>
<body>
${bodyEls}
${bodyTail}
</body>
</html>`;

        const previewDoc = code;
        return { code, preview: previewDoc };
      }

      function roundtripExport(){
        const all = state.blocks.slice();

        const headBlocks = all.filter(b=>b.domain==="head");
        const tailBlocks = all.filter(b=>b.domain==="bodytail");
        const visualBlocks = all.filter(b=>b.domain==="body" && b.visual);

        const scopeVisualOnly = (state.exportScope === "visual");

        const headHTML = scopeVisualOnly
          ? (state.project.headHTML || "")
          : headBlocks.map(b => b.outerHTML || "").join("\n") || (state.project.headHTML || "");

        const bodyTailHTML = scopeVisualOnly
          ? (state.project.bodyTailHTML || "")
          : tailBlocks.map(b => b.outerHTML || "").join("\n") || (state.project.bodyTailHTML || "");

        const vis = visualBlocks.slice();
        if(!vis.length){
          const empty =
`<!doctype html><html lang="${escapeHTML(state.project.docLang||"en")}"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>${escapeHTML(state.project.docTitle||"Untitled")}</title>${headHTML}</head><body><!-- no visual blocks -->${bodyTailHTML}</body></html>`;
          return { code: empty, preview: empty };
        }

        // stable sort (row-major by snapped z then x, stack by y)
        vis.sort((a,b)=>{
          const az = snap(a.pos.z, GRID.cell), bz = snap(b.pos.z, GRID.cell);
          const ax = snap(a.pos.x, GRID.cell), bx = snap(b.pos.x, GRID.cell);
          if(az !== bz) return az - bz;
          if(ax !== bx) return ax - bx;
          return a.pos.y - b.pos.y;
        });

        const grid = computeGridMap(vis);
        const cellPx = 110;
        const gapPx = 12;

        const gridInfo = (b)=>{
          const col = Math.round((snap(b.pos.x, GRID.cell) - grid.minX)/GRID.cell) + 1;
          const row = Math.round((snap(b.pos.z, GRID.cell) - grid.minZ)/GRID.cell) + 1;
          const stack = Math.round((b.pos.y - groundY)/GRID.yStep);
          const zIndex = 10 + stack;
          return { col, row, zIndex };
        };

        const injectedCSS =
`/* Injected by Aperture Mobile Architect (ROUNDTRIP layout) */
:root{ --cell:${cellPx}px; --gap:${gapPx}px; }
body{ margin:0; padding:12px; font-family:system-ui; background:#fff; }
#s420-stage{
  display:grid;
  grid-template-columns: repeat(${grid.cols}, var(--cell));
  grid-auto-rows: var(--cell);
  gap: var(--gap);
  align-items:stretch;
  justify-content:start;
}
#s420-stage > *{
  border:1px solid rgba(0,0,0,.12);
  border-radius:14px;
  padding:10px;
  background:#f7f7f7;
  overflow:hidden;
  position:relative;
}
#s420-stage img, #s420-stage video, #s420-stage iframe, #s420-stage canvas, #s420-stage svg{
  width:100%;
  height:100%;
  object-fit:cover;
  display:block;
  border-radius:12px;
  background:#fff;
}
`;

        const stageEls = vis.map(b => blockToElementHTML(b, gridInfo)).join("\n");

        const code =
`<!doctype html>
<html lang="${escapeHTML(state.project.docLang||"en")}">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>${escapeHTML(state.project.docTitle||"Untitled")}</title>
${headHTML}
<style>
${injectedCSS}
</style>
</head>
<body>
<div id="s420-stage">
${stageEls}
</div>
${bodyTailHTML}
</body>
</html>`;

        const previewDoc = code;
        return { code, preview: previewDoc };
      }

      function rebuildExport(force=false){
        // Update subtitle
        exportSub.textContent =
          `mode=${state.exportMode.toUpperCase()} ‚Ä¢ scope=${state.exportScope.toUpperCase()} ‚Ä¢ scripts=${state.previewScripts ? "LIVE" : "SAFE"}`;

        const out = (state.exportMode === "semantic") ? semanticExport() : roundtripExport();
        exportCode.value = out.code || "// Export Empty";

        // Preview sandbox: safe by default
        if(state.previewScripts){
          preview.setAttribute("sandbox", "allow-same-origin allow-scripts");
        } else {
          preview.setAttribute("sandbox", "allow-same-origin");
        }
        preview.srcdoc = out.preview || "";
      }

      // ---------- Editor (selected block) ----------
      function getSelected(){
        if(!state.selected) return null;
        return state.blocks.find(b=>b.id===state.selected) || null;
      }

      function loadSelectedIntoEditor(){
        const b = getSelected();
        if(!b){
          editSub.textContent = "no selection";
          editTag.value = "";
          editContent.value = "";
          editAttrs.value = "";
          editRaw.value = "";
          return;
        }
        editSub.textContent = `${b.domain.toUpperCase()} ‚Ä¢ <${b.tag}> ‚Ä¢ ${b.label}`;
        editTag.value = b.tag || "div";
        editContent.value = b.content || "";
        editAttrs.value = attrsToLines(b.attrs || {});
        editRaw.value = b.outerHTML || "";
      }

      let rawMode = false;
      btnRawEdit.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        rawMode = !rawMode;
        btnRawEdit.textContent = "RAW: " + (rawMode ? "ON" : "OFF");
        btnRawEdit.classList.toggle("on", rawMode);
        editRaw.style.display = rawMode ? "block" : "none";
        toast(rawMode ? "Raw outerHTML edit ON" : "Raw outerHTML edit OFF");
      }, {passive:false});

      btnApplyEdit.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        const b = getSelected();
        if(!b){ toast("No selected block."); return; }

        const newTag = (editTag.value || b.tag || "div").trim().toLowerCase();
        b.tag = newTag;

        // domain rule: if tag indicates head/bodytail, keep domain unless user changes explicitly via attrs
        if(["meta","link","style"].includes(newTag)) b.domain = "head";
        if(newTag === "script") b.domain = "bodytail";
        if(!["head","bodytail"].includes(b.domain)) b.domain = "body";

        b.visual = (b.domain === "body") && isVisualTag(b.tag);
        b.sizeScale = tagSizeScale(b.tag);
        b.color = tagColor(b.tag);

        // attrs + content
        b.content = String(editContent.value || "");
        b.attrs = parseAttrsLines(editAttrs.value || "");

        if(rawMode){
          b.outerHTML = String(editRaw.value || "").trim();
        } else {
          // synthesize outerHTML from tag/content/attrs
          const attrsStr = Object.keys(b.attrs).map(k=>` ${k}="${escapeHTML(b.attrs[k])}"`).join("");
          if(b.tag === "img"){
            const src = b.attrs.src || b.content || "";
            b.outerHTML = `<img${attrsStr}${b.attrs.src ? "" : ` src="${escapeHTML(src)}"`} alt="">`;
          } else if(b.tag === "input"){
            b.outerHTML = `<input${attrsStr}>`;
          } else if(b.tag === "meta"){
            b.outerHTML = `<meta${attrsStr}>`;
          } else if(b.tag === "link"){
            b.outerHTML = `<link${attrsStr}>`;
          } else if(b.tag === "style"){
            b.outerHTML = `<style${attrsStr}>\n${escapeHTML(b.content || "")}\n</style>`;
          } else if(b.tag === "script"){
            b.outerHTML = `<script${attrsStr}>\n${escapeHTML(b.content || "")}\n</script>`;
          } else {
            b.outerHTML = `<${b.tag}${attrsStr}>${escapeHTML(b.content || "")}</${b.tag}>`;
          }
        }

        b.label = summarizeForLabel(b.tag, b.attrs, b.content);
        loadSelectedIntoEditor();
        rebuildExport(true);
        toast("Applied block changes.");
      }, {passive:false});

      // ---------- Controls (canvas) ----------
      canvas.addEventListener("pointerdown", (e)=>{
        if(state.panel) return;
        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        if(state.pointers.size === 2){
          state.mode="pinchpan";
          state.dragging=null;

          const pts=[...state.pointers.values()];
          const a=pts[0], b=pts[1];
          const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const dist=Math.hypot(a.x-b.x, a.y-b.y) || 1;

          state.pinch={ startDist:dist, startMid:mid, startCamDist:cam.dist, startTarget:v3(cam.target.x, cam.target.y, cam.target.z) };
          return;
        }

        const picked = pickBlock(e.clientX, e.clientY);
        if(picked){
          state.mode="drag";
          state.dragging=picked.id;
          state.selected=picked.id;

          // bring to editor if open
          if(state.panel === "edit") loadSelectedIntoEditor();

          const ray = rayFromScreen(e.clientX, e.clientY);
          const g = ray ? intersectPlaneY(ray, groundY) : null;

          state.dragStartGround=g;
          state.dragStartPos=v3(picked.pos.x, picked.pos.y, picked.pos.z);

          // preserve stack order baseline
          picked._stackOrder = picked._stackOrder ?? 0;
          rebuildExport(true);
          return;
        }

        state.mode="orbit";
        state.selected=null;
        state.orbitLast={ x:e.clientX, y:e.clientY };
      }, {passive:false});

      canvas.addEventListener("pointermove",(e)=>{
        if(state.panel) return;
        if(!state.pointers.has(e.pointerId)) return;

        e.preventDefault();
        state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        if(state.pointers.size === 2 && state.mode==="pinchpan" && state.pinch){
          const pts=[...state.pointers.values()];
          const a=pts[0], b=pts[1];
          const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const dist=Math.hypot(a.x-b.x, a.y-b.y) || 1;

          const scale = dist / (state.pinch.startDist || dist);
          cam.dist = clamp(state.pinch.startCamDist / scale, 320, 3200);

          const mdx = mid.x - state.pinch.startMid.x;
          const mdy = mid.y - state.pinch.startMid.y;

          const eye = cameraEye();
          const fwd = norm(sub(cam.target, eye));
          const right = norm(cross(fwd, UP));
          const fwdXZ = norm(v3(fwd.x,0,fwd.z));
          const rightXZ = norm(v3(right.x,0,right.z));

          const panFactor = (cam.dist / 900) * 1.05;
          const pan = add(mul(rightXZ, -mdx*panFactor), mul(fwdXZ, mdy*panFactor));
          cam.target = add(state.pinch.startTarget, pan);
          cam.target.y = 0;
          return;
        }

        if(state.mode==="drag" && state.dragging){
          const b = state.blocks.find(x=>x.id===state.dragging);
          if(!b) return;

          // Only snap-move VISUAL blocks on the ground grid; head/bodytail blocks move within their lanes without stacking
          if(b.domain !== "body" || !b.visual){
            // lane move: simple XY plane at groundY with snap
            const ray = rayFromScreen(e.clientX, e.clientY);
            const g = ray ? intersectPlaneY(ray, groundY) : null;
            if(!g) return;
            b.pos.x = snap(g.x, GRID.cell);
            b.pos.z = snap(g.z, GRID.cell);
            b.pos.y = groundY;
            rebuildExport(true);
            return;
          }

          const ray = rayFromScreen(e.clientX, e.clientY);
          const g = ray ? intersectPlaneY(ray, groundY) : null;
          if(!g || !state.dragStartGround || !state.dragStartPos) return;

          const desiredX = state.dragStartPos.x + (g.x - state.dragStartGround.x);
          const desiredZ = state.dragStartPos.z + (g.z - state.dragStartGround.z);

          // Update stack order so the moved block becomes "top" in target cell
          const p = placeOnGrid(desiredX, desiredZ, b.id, true);
          const newKey = `${p.x}|${p.z}`;

          // Set stack order to end of group
          const group = state.blocks.filter(o=>o.visual && o.domain==="body" && cellKey(o.pos.x,o.pos.z)===newKey && o.id!==b.id);
          const maxOrder = group.reduce((m,o)=>Math.max(m, o._stackOrder||0), 0);
          b._stackOrder = maxOrder + 1;

          b.pos.x = p.x; b.pos.z = p.z;
          normalizeStacks();

          rebuildExport(false);
          return;
        }

        if(state.mode==="orbit" && state.orbitLast){
          const dx=e.clientX-state.orbitLast.x;
          const dy=e.clientY-state.orbitLast.y;
          state.orbitLast.x=e.clientX;
          state.orbitLast.y=e.clientY;

          cam.yaw += dx * 0.0055;
          cam.pitch = clamp(cam.pitch - dy * 0.0055, 0.12, 1.35);
          return;
        }
      }, {passive:false});

      function endPointer(e){
        if(state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);
        if(state.pointers.size < 2 && state.mode==="pinchpan"){ state.mode="none"; state.pinch=null; }
        if(state.pointers.size === 0){
          state.mode="none";
          state.dragging=null;
          state.dragStartGround=null;
          state.dragStartPos=null;
          state.orbitLast=null;
          normalizeStacks();
          rebuildExport(true);
        }
      }
      canvas.addEventListener("pointerup", endPointer, {passive:true});
      canvas.addEventListener("pointercancel", endPointer, {passive:true});

      window.addEventListener("keydown",(e)=>{
        if(e.key === "Escape"){
          if(state.panel) closePanel();
          else if(picker.classList.contains("open")) setPicker(false);
        }
      });

      // ---------- HUD label projection ----------
      function projectToScreen(vp, p){
        const x=p.x, y=p.y, z=p.z;
        const cx = vp[0]*x + vp[4]*y + vp[8]*z + vp[12];
        const cy = vp[1]*x + vp[5]*y + vp[9]*z + vp[13];
        const cz = vp[2]*x + vp[6]*y + vp[10]*z + vp[14];
        const cw = vp[3]*x + vp[7]*y + vp[11]*z + vp[15];
        if(cw === 0) return null;
        const ndcX = cx / cw, ndcY = cy / cw, ndcZ = cz / cw;
        if(ndcZ < -1 || ndcZ > 1) return null;
        const sx = (ndcX * 0.5 + 0.5) * hud.width;
        const sy = (1 - (ndcY * 0.5 + 0.5)) * hud.height;
        return { sx, sy, ndcZ };
      }

      // ---------- Rendering ----------
      function drawCube(pos, size, color, alpha, vp){
        gl.uniformMatrix4fv(loc.u_vp, false, vp);
        gl.uniform3f(loc.u_objPos, pos.x, pos.y, pos.z);
        gl.uniform1f(loc.u_objSize, size);
        gl.uniform3f(loc.u_color, color[0], color[1], color[2]);
        gl.uniform3f(loc.u_lightDir, -0.35, 0.85, 0.25);
        gl.uniform1f(loc.u_alpha, alpha);
        gl.drawArrays(gl.TRIANGLES, 0, cube.count);
      }

      function drawGround(vp){
        for(let z=-900; z<=700; z+=90){
          for(let x=-900; x<=900; x+=90){
            drawCube(v3(x, 0.0, z), 1.2, [0.25,0.25,0.25], 0.10, vp);
          }
        }
      }

      function renderHUD(vp){
        h2d.clearRect(0,0,hud.width,hud.height);

        const dpr = DPR();
        h2d.font = `${Math.round(12*dpr)}px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace`;
        h2d.textBaseline = "middle";

        // Draw labels for selected + nearby, plus lanes titles
        const labels = [];
        for(const b of state.blocks){
          // reduce clutter: show all labels when help on; otherwise show selected + head/bodytail small + nearby
          const show = state.helpOn || state.selected === b.id || b.domain !== "body" || (b.domain==="body" && b.visual);
          if(!show) continue;

          const p = v3(b.pos.x, b.pos.y + (cubeSize*(b.sizeScale||1))*0.65, b.pos.z);
          const s = projectToScreen(vp, p);
          if(!s) continue;
          labels.push({ b, ...s });
        }
        labels.sort((a,b)=>a.ndcZ - b.ndcZ);

        for(const L of labels){
          const b = L.b;
          const text = (state.selected === b.id) ? (`‚ñ∂ <${b.tag}> ${b.label}`) : (`<${b.tag}> ${b.label}`);
          const pad = 6*dpr;
          const w = h2d.measureText(text).width + pad*2;
          const x = clamp(L.sx - w/2, 6*dpr, hud.width - w - 6*dpr);
          const y = clamp(L.sy, 24*dpr, hud.height - 24*dpr);

          h2d.fillStyle = (state.selected === b.id) ? "rgba(245,128,37,0.92)" : (b.domain==="head" ? "rgba(0,170,255,0.70)" : (b.domain==="bodytail" ? "rgba(255,120,80,0.70)" : "rgba(0,0,0,0.55)"));
          h2d.fillRect(x, y - 10*dpr, w, 20*dpr);

          h2d.fillStyle = "rgba(255,255,255,0.95)";
          h2d.fillText(text, x + pad, y);
        }
      }

      function render(){
        resize();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const { vp } = getVP();

        drawGround(vp);

        // Draw lane markers (simple small cubes)
        const laneMarker = (x0,z0,color)=>{
          for(let i=0;i<10;i++){
            drawCube(v3(x0 + i*GRID.cell, 1.2, z0 - GRID.cell*0.7), 1.0, color, 0.22, vp);
          }
        };
        laneMarker(lanes.head.x0, lanes.head.z0, TAG_COLORS.style);
        laneMarker(lanes.bodytail.x0, lanes.bodytail.z0, TAG_COLORS.script);

        // Draw blocks
        for(const b of state.blocks){
          const size = cubeSize * (b.sizeScale || 1);
          const col = b.color || TAG_COLORS.other;

          drawCube(b.pos, size, col, 1.0, vp);

          // cap: small indicator cube for domain/type differentiation
          const capY = b.pos.y + (size*0.75);
          const capCol = (b.domain==="head") ? TAG_COLORS.link : (b.domain==="bodytail" ? TAG_COLORS.script : TAG_COLORS.accent);
          drawCube(v3(b.pos.x + size*0.28, capY, b.pos.z + size*0.28), size*0.18, capCol, 0.90, vp);

          if(state.selected === b.id){
            drawCube(b.pos, size*1.10, TAG_COLORS.accent, 0.22, vp);
          }
        }

        renderHUD(vp);

        requestAnimationFrame(render);
      }

      // ---------- Seed minimal demo blocks (still removable) ----------
      addBlock("header");
      addBlock("h1");
      addBlock("p");
      addBlock("button");
      addBlock("img");
      addBlock("section");
      addBlock("div");
      addBlock("script", "bodytail");
      addBlock("style", "head");
      focusOnVisual();

      // ---------- Start ----------
      rebuildExport(true);
      render();
    })();
  </script>
</body>
  </html>
