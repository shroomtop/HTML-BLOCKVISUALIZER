<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="theme-color" content="#151515" />
  <title>Aperture Mobile Architect ‚Äî 3D HTML Block Editor (STACK + ROUNDTRIP + NAV FIX)</title>
  <style>
    :root{
      --bg:#151515;
      --panel:#1e1e1e;
      --panel2:#252526;
      --accent:#f58025;
      --accent2:#00aaff;
      --muted:rgba(255,255,255,.78);
      --muted2:rgba(255,255,255,.55);

      --sa-top: env(safe-area-inset-top, 0px);
      --sa-right: env(safe-area-inset-right, 0px);
      --sa-bottom: env(safe-area-inset-bottom, 0px);
      --sa-left: env(safe-area-inset-left, 0px);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      overflow:hidden;
      background:var(--bg);
      font-family:system-ui,-apple-system,"Segoe UI",sans-serif;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
      color:white;
    }
    canvas#gl{
      position:absolute; inset:0;
      width:100vw; height:100vh;
      display:block;
      touch-action:none;
    }

    /* UI root */
    #ui{ position:absolute; inset:0; pointer-events:none; }

    .btn{
      pointer-events:auto;
      position:absolute;
      min-width:54px; height:54px;
      padding:0 14px;
      border-radius:16px;
      border:2px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.55);
      color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-weight:900;
      font-size:18px;
      letter-spacing:.2px;
      touch-action:none;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      transition: transform .08s ease;
      gap:8px;
    }
    .btn:active{ transform:scale(.96); background:rgba(245,128,37,.7); border-color:rgba(245,128,37,.9); }
    .btn.small{ height:44px; min-width:44px; padding:0 12px; border-radius:14px; font-size:14px; }

    #btn-add   { top:calc(14px + var(--sa-top)); left:calc(14px + var(--sa-left)); }
    #btn-del   { top:calc(14px + var(--sa-top)); left:calc(86px + var(--sa-left)); padding:0 12px; min-width:54px;}
    #btn-help  { top:calc(14px + var(--sa-top)); right:calc(158px + var(--sa-right)); min-width:54px; }
    #btn-export{ top:calc(14px + var(--sa-top)); right:calc(86px + var(--sa-right)); }
    #btn-import{ top:calc(14px + var(--sa-top)); right:calc(14px + var(--sa-right)); }

    #toast{
      position:absolute;
      left:50%;
      bottom:calc(18px + var(--sa-bottom));
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      color:rgba(255,255,255,.92);
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      max-width:92vw;
      pointer-events:none;
      opacity:0;
      transition: opacity .18s ease, transform .18s ease;
      white-space:pre-line;
      z-index:9999;
    }
    #toast.on{ opacity:1; transform:translateX(-50%) translateY(-4px); }

    #hint{
      position:absolute;
      left:calc(14px + var(--sa-left));
      bottom:calc(82px + var(--sa-bottom));
      padding:10px 12px;
      border-radius:14px;
      background:rgba(0,0,0,.35);
      color:var(--muted);
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      max-width:94vw;
      line-height:1.25;
      pointer-events:none;
      white-space:pre-line;
      display:none;
      border:1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }

    /* Picker (tag selection) */
    #picker{
      pointer-events:auto;
      position:absolute;
      left:calc(14px + var(--sa-left));
      top:calc(78px + var(--sa-top));
      width:min(94vw, 520px);
      padding:10px;
      border-radius:16px;
      border:2px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.58);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:none;
      z-index:50;
    }
    #picker.open{ display:block; }
    #pickerTop{
      display:flex; gap:8px; align-items:center; justify-content:space-between;
      margin-bottom:8px;
    }
    #pickerTitle{
      font-weight:900; letter-spacing:.7px;
      color:rgba(255,255,255,.90);
      font-size:12px;
    }
    #pickerClose{
      border:0; background:rgba(255,255,255,.08);
      color:#fff; border-radius:12px;
      padding:8px 10px;
      font-weight:900;
      touch-action:none;
    }
    #pickerClose:active{ background:rgba(245,128,37,.7); }

    #pickerSearch{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.06);
      color:#fff;
      padding:10px 12px;
      outline:none;
      font-size:13px;
      font-weight:700;
      margin-bottom:8px;
      touch-action:auto;
      user-select:text;
      -webkit-user-select:text;
    }
    #pickerTabs{
      display:flex; gap:8px; flex-wrap:wrap;
      margin-bottom:8px;
    }
    .tab{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#fff;
      padding:8px 10px;
      border-radius:14px;
      font-weight:900;
      font-size:11px;
      letter-spacing:.25px;
      touch-action:none;
    }
    .tab.on{
      background:rgba(245,128,37,.65);
      border-color:rgba(245,128,37,.9);
    }
    .pick-grid{
      display:none;
      grid-template-columns: repeat(auto-fill, minmax(92px, 1fr));
      gap:8px;
    }
    .pick-grid.on{ display:grid; }
    .pill{
      border:2px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.08);
      color:#fff;
      padding:10px 10px;
      border-radius:14px;
      font-weight:950;
      font-size:12px;
      letter-spacing:.25px;
      touch-action:none;
      text-align:center;
      user-select:none;
      -webkit-user-select:none;
      display:flex; align-items:center; justify-content:center;
      min-height:44px;
    }
    .pill:active{ background:rgba(245,128,37,.7); border-color:rgba(245,128,37,.9); }
    .pill small{ display:block; font-size:10px; opacity:.75; font-weight:800; margin-top:2px; }

    /* Panels + Scrim */
    #scrim{
      position:absolute; inset:0;
      background:rgba(0,0,0,.55);
      opacity:0;
      pointer-events:none;
      transition: opacity .18s ease;
      z-index:60;
    }
    #scrim.open{ opacity:1; pointer-events:auto; }

    .panel{
      position:absolute;
      left:0; right:0; bottom:0;
      height:min(62vh, 560px);
      background:var(--panel);
      border-top:4px solid var(--accent);
      transform:translateY(110%);
      transition: transform .22s cubic-bezier(.2,.8,.2,1);
      z-index:70;
      pointer-events:auto;
      display:flex; flex-direction:column;
      box-shadow:0 -10px 30px rgba(0,0,0,.75);
    }
    .panel.open{ transform:translateY(0); }
    .panelHead{
      background:var(--panel2);
      padding:10px 12px;
      display:flex; align-items:center; justify-content:space-between;
      font-weight:950;
      letter-spacing:.7px;
      gap:10px;
    }
    .panelHead .left{
      display:flex; align-items:center; gap:10px;
      font-size:12px;
      opacity:.95;
    }
    .panelHead .right{
      display:flex; align-items:center; gap:8px;
    }
    .xbtn{
      border:none; background:rgba(255,255,255,.08);
      color:#fff;
      font-size:18px; padding:10px 12px;
      border-radius:12px;
      touch-action:none;
      font-weight:950;
    }
    .xbtn:active{ background:rgba(245,128,37,.7); }

    .row{
      display:flex;
      gap:8px;
      padding:10px 12px;
      flex-wrap:wrap;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .chip{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#fff;
      padding:9px 10px;
      border-radius:14px;
      font-weight:950;
      font-size:12px;
      touch-action:none;
      user-select:none;
      -webkit-user-select:none;
    }
    .chip.on{
      background:rgba(0,170,255,.35);
      border-color:rgba(0,170,255,.65);
    }
    .chip:active{ background:rgba(245,128,37,.65); border-color:rgba(245,128,37,.9); }

    .mono{
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:rgba(255,255,255,.85);
    }

    textarea.big{
      width:100%;
      flex:1;
      resize:none;
      border:0;
      outline:none;
      padding:12px;
      background:#111;
      color:#d4d4d4;
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre;
      overflow:auto;

      /* critical: allow text interaction even though body is touch-action:none */
      touch-action:auto;
      user-select:text;
      -webkit-user-select:text;
    }

    /* Import helper rows */
    .kv{
      padding:10px 12px;
      border-top:1px solid rgba(255,255,255,.06);
      color:rgba(255,255,255,.82);
      font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-line;
    }

    /* Edit panel fields */
    .field{
      padding:10px 12px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .field label{
      display:block;
      font-size:11px;
      font-weight:950;
      letter-spacing:.6px;
      color:rgba(255,255,255,.75);
      margin-bottom:6px;
    }
    .field input, .field textarea{
      width:100%;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      color:#fff;
      padding:10px 12px;
      outline:none;
      font-size:13px;
      font-weight:750;
      touch-action:auto;
      user-select:text;
      -webkit-user-select:text;
    }
    .field textarea{ min-height:92px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }

    #fatal{
      position:absolute; inset:0;
      display:none;
      align-items:flex-start; justify-content:flex-start;
      padding:16px;
      background:#0b0b0b;
      color:#fff;
      font: 13px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      z-index:99999;
      touch-action:auto;
      user-select:text;
      -webkit-user-select:text;
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>

  <div id="ui">
    <button id="btn-add" class="btn" type="button" aria-label="Add block">Ôºã</button>
    <button id="btn-del" class="btn" type="button" aria-label="Delete selected">üóë</button>
    <button id="btn-help" class="btn" type="button" aria-label="Help">‚ùî</button>
    <button id="btn-export" class="btn" type="button" aria-label="Export">‚úé</button>
    <button id="btn-import" class="btn" type="button" aria-label="Import">‚§ì</button>

    <div id="picker" aria-label="Block type picker">
      <div id="pickerTop">
        <div id="pickerTitle">ADD BLOCK (HTML TAG)</div>
        <button id="pickerClose" type="button">‚úï</button>
      </div>

      <input id="pickerSearch" placeholder="Search tags‚Ä¶ (e.g. header, button, table, script)" />

      <div id="pickerTabs">
        <button class="tab on" data-tab="struct">STRUCT</button>
        <button class="tab" data-tab="text">TEXT</button>
        <button class="tab" data-tab="media">MEDIA</button>
        <button class="tab" data-tab="form">FORM</button>
        <button class="tab" data-tab="table">TABLE</button>
        <button class="tab" data-tab="code">CODE</button>
        <button class="tab" data-tab="head">HEAD</button>
      </div>

      <div class="pick-grid on" data-grid="struct">
        <button class="pill" data-tag="header" data-domain="body">HEADER</button>
        <button class="pill" data-tag="nav" data-domain="body">NAV</button>
        <button class="pill" data-tag="main" data-domain="body">MAIN</button>
        <button class="pill" data-tag="section" data-domain="body">SECTION</button>
        <button class="pill" data-tag="article" data-domain="body">ARTICLE</button>
        <button class="pill" data-tag="aside" data-domain="body">ASIDE</button>
        <button class="pill" data-tag="footer" data-domain="body">FOOTER</button>
        <button class="pill" data-tag="div" data-domain="body">DIV</button>
        <button class="pill" data-tag="ul" data-domain="body">UL</button>
        <button class="pill" data-tag="ol" data-domain="body">OL</button>
        <button class="pill" data-tag="li" data-domain="body">LI</button>
        <button class="pill" data-tag="hr" data-domain="body">HR</button>
      </div>

      <div class="pick-grid" data-grid="text">
        <button class="pill" data-tag="h1" data-domain="body">H1</button>
        <button class="pill" data-tag="h2" data-domain="body">H2</button>
        <button class="pill" data-tag="h3" data-domain="body">H3</button>
        <button class="pill" data-tag="p" data-domain="body">P</button>
        <button class="pill" data-tag="span" data-domain="body">SPAN</button>
        <button class="pill" data-tag="a" data-domain="body">A</button>
        <button class="pill" data-tag="strong" data-domain="body">STRONG</button>
        <button class="pill" data-tag="em" data-domain="body">EM</button>
        <button class="pill" data-tag="code" data-domain="body">CODE</button>
        <button class="pill" data-tag="pre" data-domain="body">PRE</button>
        <button class="pill" data-tag="blockquote" data-domain="body">QUOTE</button>
      </div>

      <div class="pick-grid" data-grid="media">
        <button class="pill" data-tag="img" data-domain="body">IMG</button>
        <button class="pill" data-tag="video" data-domain="body">VIDEO</button>
        <button class="pill" data-tag="audio" data-domain="body">AUDIO</button>
        <button class="pill" data-tag="canvas" data-domain="body">CANVAS</button>
        <button class="pill" data-tag="svg" data-domain="body">SVG</button>
        <button class="pill" data-tag="iframe" data-domain="body">IFRAME</button>
      </div>

      <div class="pick-grid" data-grid="form">
        <button class="pill" data-tag="form" data-domain="body">FORM</button>
        <button class="pill" data-tag="label" data-domain="body">LABEL</button>
        <button class="pill" data-tag="input" data-domain="body">INPUT</button>
        <button class="pill" data-tag="textarea" data-domain="body">TEXTAREA</button>
        <button class="pill" data-tag="select" data-domain="body">SELECT</button>
        <button class="pill" data-tag="option" data-domain="body">OPTION</button>
        <button class="pill" data-tag="button" data-domain="body">BUTTON</button>
      </div>

      <div class="pick-grid" data-grid="table">
        <button class="pill" data-tag="table" data-domain="body">TABLE</button>
        <button class="pill" data-tag="thead" data-domain="body">THEAD</button>
        <button class="pill" data-tag="tbody" data-domain="body">TBODY</button>
        <button class="pill" data-tag="tr" data-domain="body">TR</button>
        <button class="pill" data-tag="th" data-domain="body">TH</button>
        <button class="pill" data-tag="td" data-domain="body">TD</button>
      </div>

      <div class="pick-grid" data-grid="code">
        <button class="pill" data-tag="style" data-domain="head">STYLE <small>HEAD</small></button>
        <button class="pill" data-tag="script" data-domain="tail">SCRIPT <small>BODYTAIL</small></button>
        <button class="pill" data-tag="link" data-domain="head">LINK <small>HEAD</small></button>
        <button class="pill" data-tag="meta" data-domain="head">META <small>HEAD</small></button>
      </div>

      <div class="pick-grid" data-grid="head">
        <button class="pill" data-tag="title" data-domain="head">TITLE</button>
        <button class="pill" data-tag="meta" data-domain="head">META</button>
        <button class="pill" data-tag="link" data-domain="head">LINK</button>
        <button class="pill" data-tag="style" data-domain="head">STYLE</button>
        <button class="pill" data-tag="script" data-domain="tail">SCRIPT <small>BODYTAIL</small></button>
      </div>

      <div style="margin-top:10px; color:rgba(255,255,255,.65); font-size:11px; line-height:1.25;">
        Drag cube: snapped grid (no overlap). Same cell stacks (levels).<br>
        Drag empty: orbit. Pinch: zoom. Two-finger drag: pan target.<br>
        Export panel: COPY / SELECT / DOWNLOAD.
      </div>
    </div>

    <div id="scrim"></div>

    <!-- EXPORT PANEL -->
    <div id="panelExport" class="panel" role="dialog" aria-label="Export" aria-hidden="true">
      <div class="panelHead">
        <div class="left">EXPORT + COPY (ROUNDTRIP)</div>
        <div class="right">
          <button id="btnExportClose" class="xbtn" type="button" aria-label="Close">‚úï</button>
        </div>
      </div>
      <div class="row">
        <button id="btnCopy" class="chip" type="button">COPY</button>
        <button id="btnSelect" class="chip" type="button">SELECT</button>
        <button id="btnDownload" class="chip" type="button">DOWNLOAD</button>
        <button id="btnRebuild" class="chip" type="button">REBUILD</button>
        <button id="btnScope" class="chip on" type="button" title="ALL exports head+body+tail; VISUAL exports only visual blocks">SCOPE: ALL</button>
        <button id="btnPreviewMode" class="chip" type="button" title="SAFE preview blocks scripts; LIVE allows scripts">PREVIEW: SAFE</button>
      </div>
      <textarea id="exportCode" class="big" spellcheck="false"></textarea>
      <div class="kv" id="exportStats"></div>
    </div>

    <!-- IMPORT PANEL -->
    <div id="panelImport" class="panel" role="dialog" aria-label="Import" aria-hidden="true">
      <div class="panelHead">
        <div class="left">IMPORT HTML ‚Üí BLOCKS</div>
        <div class="right">
          <button id="btnImportClose" class="xbtn" type="button" aria-label="Close">‚úï</button>
        </div>
      </div>
      <div class="row">
        <button id="btnPaste" class="chip" type="button">PASTE</button>
        <button id="btnVisualize" class="chip" type="button">VISUALIZE</button>
        <button id="btnClearImport" class="chip" type="button">CLEAR</button>
        <button id="btnDepth" class="chip on" type="button" title="TOP: body children only; DEEP: traverse nested nodes">DEPTH: TOP</button>
        <button id="btnReplace" class="chip on" type="button" title="REPLACE: wipe existing blocks; MERGE: add to current">MODE: REPLACE</button>
      </div>
      <textarea id="importText" class="big" spellcheck="false" placeholder="Paste HTML (fragment or full document).&#10;&#10;Goal: import ‚Üí visualize blocks ‚Üí move blocks ‚Üí export updates ‚Üí copy/download."></textarea>
      <div class="kv" id="importStats"></div>
    </div>

    <!-- EDIT PANEL -->
    <div id="panelEdit" class="panel" role="dialog" aria-label="Edit block" aria-hidden="true">
      <div class="panelHead">
        <div class="left">EDIT SELECTED BLOCK</div>
        <div class="right">
          <button id="btnEditClose" class="xbtn" type="button" aria-label="Close">‚úï</button>
        </div>
      </div>
      <div class="row">
        <button id="btnApplyEdit" class="chip" type="button">APPLY</button>
        <button id="btnRaw" class="chip" type="button" title="RAW on: use outerHTML directly">RAW: OFF</button>
        <button id="btnNudgeUp" class="chip" type="button" title="Increase stack level (same cell)">STACK +</button>
        <button id="btnNudgeDown" class="chip" type="button" title="Decrease stack level (same cell)">STACK -</button>
      </div>

      <div class="field">
        <label>Info</label>
        <div class="mono" id="editInfo">no selection</div>
      </div>

      <div class="field">
        <label>Tag (editable)</label>
        <input id="editTag" placeholder="div, h1, img, button, ..." />
      </div>

      <div class="field">
        <label>Label/content (text tags use text; IMG uses src; A uses href; INPUT uses value/placeholder)</label>
        <input id="editContent" placeholder="Hello world / https://... / etc" />
      </div>

      <div class="field">
        <label>Attributes (one per line). Example: id=&quot;hero&quot; class=&quot;card&quot; src=&quot;...&quot; href=&quot;...&quot;</label>
        <textarea id="editAttrs" placeholder='id="hero"
class="card"
style="color:red"'></textarea>
      </div>

      <div class="field">
        <label>Raw outerHTML (optional). Turn RAW on to edit exact element markup.</label>
        <textarea id="editOuter" placeholder="<div class=&quot;card&quot;>Hello</div>"></textarea>
      </div>
    </div>

    <div id="hint"></div>
    <div id="toast"></div>
  </div>

  <div id="fatal"></div>

  <script>
    (() => {
      /* ========== FAIL HARD ========== */
      const fatalEl = document.getElementById('fatal');
      const die = (msg) => {
        fatalEl.style.display = "flex";
        fatalEl.textContent = msg;
        throw new Error(msg);
      };
      window.addEventListener('error', (e)=>{ die("[JS ERROR]\\n" + (e.error && e.error.stack ? e.error.stack : e.message)); });
      window.addEventListener('unhandledrejection', (e)=>{ die("[PROMISE REJECT]\\n" + (e.reason && e.reason.stack ? e.reason.stack : String(e.reason))); });

      /* ========== DOM ========== */
      const canvas = document.getElementById('gl');
      const gl = canvas.getContext('webgl', { antialias:true, alpha:false, depth:true, premultipliedAlpha:false });
      if (!gl) die("WebGL not available.");

      const $ = (id)=>document.getElementById(id);

      const btnAdd = $('btn-add');
      const btnDel = $('btn-del');
      const btnHelp = $('btn-help');
      const btnExportOpen = $('btn-export');
      const btnImportOpen = $('btn-import');

      const picker = $('picker');
      const pickerClose = $('pickerClose');
      const pickerSearch = $('pickerSearch');

      const scrim = $('scrim');

      const panelExport = $('panelExport');
      const panelImport = $('panelImport');
      const panelEdit   = $('panelEdit');

      const btnExportClose = $('btnExportClose');
      const btnImportClose = $('btnImportClose');
      const btnEditClose   = $('btnEditClose');

      const exportCode = $('exportCode');
      const exportStats= $('exportStats');
      const btnCopy    = $('btnCopy');
      const btnSelect  = $('btnSelect');
      const btnDownload= $('btnDownload');
      const btnRebuild = $('btnRebuild');
      const btnScope   = $('btnScope');
      const btnPreviewMode = $('btnPreviewMode');

      const importText = $('importText');
      const importStats= $('importStats');
      const btnPaste   = $('btnPaste');
      const btnVisualize = $('btnVisualize');
      const btnClearImport = $('btnClearImport');
      const btnDepth = $('btnDepth');
      const btnReplace = $('btnReplace');

      const editInfo = $('editInfo');
      const editTag = $('editTag');
      const editContent = $('editContent');
      const editAttrs = $('editAttrs');
      const editOuter = $('editOuter');
      const btnApplyEdit = $('btnApplyEdit');
      const btnRaw = $('btnRaw');
      const btnNudgeUp = $('btnNudgeUp');
      const btnNudgeDown = $('btnNudgeDown');

      const hint = $('hint');
      const toastEl = $('toast');

      /* ========== TOAST ========== */
      let toastTimer = null;
      function toast(msg, ms=1400){
        toastEl.textContent = String(msg || "");
        toastEl.classList.add("on");
        clearTimeout(toastTimer);
        toastTimer = setTimeout(()=>toastEl.classList.remove("on"), ms);
      }

      /* ========== DPI RESIZE ========== */
      const DPR = () => Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      function resize(){
        const dpr = DPR();
        const w = Math.floor(innerWidth * dpr);
        const h = Math.floor(innerHeight * dpr);
        if (canvas.width !== w || canvas.height !== h){
          canvas.width = w; canvas.height = h;
          canvas.style.width = innerWidth + "px";
          canvas.style.height = innerHeight + "px";
          gl.viewport(0,0,w,h);
        }
      }
      addEventListener('resize', resize, { passive:true });
      resize();

      /* ========== MATH ========== */
      const v3=(x=0,y=0,z=0)=>({x,y,z});
      const add=(a,b)=>v3(a.x+b.x,a.y+b.y,a.z+b.z);
      const sub=(a,b)=>v3(a.x-b.x,a.y-b.y,a.z-b.z);
      const mul=(a,s)=>v3(a.x*s,a.y*s,a.z*s);
      const dot=(a,b)=>a.x*b.x+a.y*b.y+a.z*b.z;
      const cross=(a,b)=>v3(a.y*b.z-a.z*b.y, a.z*b.x-a.x*b.z, a.x*b.y-a.y*b.x);
      const len=(a)=>Math.hypot(a.x,a.y,a.z);
      const norm=(a)=>{ const L=len(a)||1; return v3(a.x/L,a.y/L,a.z/L); };
      const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));

      /* ========== MAT4 (COLUMN-MAJOR) ========== */
      const m4 = {
        multiply(a,b){
          const o = new Float32Array(16);
          const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
          const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
          const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
          const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

          const b00=b[0],b01=b[1],b02=b[2],b03=b[3];
          const b10=b[4],b11=b[5],b12=b[6],b13=b[7];
          const b20=b[8],b21=b[9],b22=b[10],b23=b[11];
          const b30=b[12],b31=b[13],b32=b[14],b33=b[15];

          o[0]=a00*b00 + a10*b01 + a20*b02 + a30*b03;
          o[1]=a01*b00 + a11*b01 + a21*b02 + a31*b03;
          o[2]=a02*b00 + a12*b01 + a22*b02 + a32*b03;
          o[3]=a03*b00 + a13*b01 + a23*b02 + a33*b03;

          o[4]=a00*b10 + a10*b11 + a20*b12 + a30*b13;
          o[5]=a01*b10 + a11*b11 + a21*b12 + a31*b13;
          o[6]=a02*b10 + a12*b11 + a22*b12 + a32*b13;
          o[7]=a03*b10 + a13*b11 + a23*b12 + a33*b13;

          o[8]=a00*b20 + a10*b21 + a20*b22 + a30*b23;
          o[9]=a01*b20 + a11*b21 + a21*b22 + a31*b23;
          o[10]=a02*b20 + a12*b21 + a22*b22 + a32*b23;
          o[11]=a03*b20 + a13*b21 + a23*b22 + a33*b23;

          o[12]=a00*b30 + a10*b31 + a20*b32 + a30*b33;
          o[13]=a01*b30 + a11*b31 + a21*b32 + a31*b33;
          o[14]=a02*b30 + a12*b31 + a22*b32 + a32*b33;
          o[15]=a03*b30 + a13*b31 + a23*b32 + a33*b33;
          return o;
        },
        perspective(fovy, aspect, near, far){
          const f = 1.0 / Math.tan(fovy / 2);
          const nf = 1 / (near - far);
          const o = new Float32Array(16);
          o[0] = f / aspect;
          o[5] = f;
          o[10] = (far + near) * nf;
          o[11] = -1;
          o[14] = (2 * far * near) * nf;
          return o;
        },
        lookAt(eye, center, up){
          const o = new Float32Array(16);
          let z0 = eye.x - center.x, z1 = eye.y - center.y, z2 = eye.z - center.z;
          let L = Math.hypot(z0,z1,z2);
          if (L === 0) { z2 = 1; }
          else { z0/=L; z1/=L; z2/=L; }

          let x0 = up.y * z2 - up.z * z1;
          let x1 = up.z * z0 - up.x * z2;
          let x2 = up.x * z1 - up.y * z0;
          L = Math.hypot(x0,x1,x2);
          if (L === 0){ x0=0; x1=0; x2=0; }
          else { x0/=L; x1/=L; x2/=L; }

          let y0 = z1 * x2 - z2 * x1;
          let y1 = z2 * x0 - z0 * x2;
          let y2 = z0 * x1 - z1 * x0;

          o[0]=x0; o[1]=y0; o[2]=z0; o[3]=0;
          o[4]=x1; o[5]=y1; o[6]=z1; o[7]=0;
          o[8]=x2; o[9]=y2; o[10]=z2; o[11]=0;
          o[12]=-(x0*eye.x + x1*eye.y + x2*eye.z);
          o[13]=-(y0*eye.x + y1*eye.y + y2*eye.z);
          o[14]=-(z0*eye.x + z1*eye.y + z2*eye.z);
          o[15]=1;
          return o;
        },
        invert(a){
          const o = new Float32Array(16);
          const a00=a[0],a01=a[1],a02=a[2],a03=a[3];
          const a10=a[4],a11=a[5],a12=a[6],a13=a[7];
          const a20=a[8],a21=a[9],a22=a[10],a23=a[11];
          const a30=a[12],a31=a[13],a32=a[14],a33=a[15];

          const b00 = a00 * a11 - a01 * a10;
          const b01 = a00 * a12 - a02 * a10;
          const b02 = a00 * a13 - a03 * a10;
          const b03 = a01 * a12 - a02 * a11;
          const b04 = a01 * a13 - a03 * a11;
          const b05 = a02 * a13 - a03 * a12;
          const b06 = a20 * a31 - a21 * a30;
          const b07 = a20 * a32 - a22 * a30;
          const b08 = a20 * a33 - a23 * a30;
          const b09 = a21 * a32 - a22 * a31;
          const b10 = a21 * a33 - a23 * a31;
          const b11 = a22 * a33 - a23 * a32;

          let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
          if (!det) return null;
          det = 1.0 / det;

          o[0] = ( a11 * b11 - a12 * b10 + a13 * b09) * det;
          o[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * det;
          o[2] = ( a31 * b05 - a32 * b04 + a33 * b03) * det;
          o[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * det;
          o[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * det;
          o[5] = ( a00 * b11 - a02 * b08 + a03 * b07) * det;
          o[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * det;
          o[7] = ( a20 * b05 - a22 * b02 + a23 * b01) * det;
          o[8] = ( a10 * b10 - a11 * b08 + a13 * b06) * det;
          o[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * det;
          o[10]= ( a30 * b04 - a31 * b02 + a33 * b00) * det;
          o[11]= (-a20 * b04 + a21 * b02 - a23 * b00) * det;
          o[12]= (-a10 * b09 + a11 * b07 - a12 * b06) * det;
          o[13]= ( a00 * b09 - a01 * b07 + a02 * b06) * det;
          o[14]= (-a30 * b03 + a31 * b01 - a32 * b00) * det;
          o[15]= ( a20 * b03 - a21 * b01 + a22 * b00) * det;
          return o;
        }
      };

      function unproject(nx, ny, nz, invVP){
        const x=nx, y=ny, z=nz, w=1;
        const ox = invVP[0]*x + invVP[4]*y + invVP[8]*z + invVP[12]*w;
        const oy = invVP[1]*x + invVP[5]*y + invVP[9]*z + invVP[13]*w;
        const oz = invVP[2]*x + invVP[6]*y + invVP[10]*z + invVP[14]*w;
        const ow = invVP[3]*x + invVP[7]*y + invVP[11]*z + invVP[15]*w;
        if (ow === 0) return null;
        return v3(ox/ow, oy/ow, oz/ow);
      }

      /* ========== SHADERS ========== */
      function compile(type, src){
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
          const e = gl.getShaderInfoLog(s) || "unknown";
          gl.deleteShader(s);
          die("Shader compile error:\\n" + e);
        }
        return s;
      }
      function link(vs, fs){
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
          const e = gl.getProgramInfoLog(p) || "unknown";
          gl.deleteProgram(p);
          die("Program link error:\\n" + e);
        }
        return p;
      }

      const VS = `
        attribute vec3 a_pos;
        attribute vec3 a_nrm;
        uniform mat4 u_vp;
        uniform vec3 u_objPos;
        uniform vec3 u_objScale;
        varying vec3 v_nrm;
        void main(){
          vec3 p = a_pos * u_objScale + u_objPos;
          v_nrm = a_nrm;
          gl_Position = u_vp * vec4(p, 1.0);
        }
      `;
      const FS = `
        precision mediump float;
        uniform vec3 u_color;
        uniform vec3 u_lightDir;
        uniform float u_alpha;
        varying vec3 v_nrm;
        void main(){
          float ndl = max(dot(normalize(v_nrm), normalize(u_lightDir)), 0.0);
          float shade = 0.22 + ndl * 0.78;
          gl_FragColor = vec4(u_color * shade, u_alpha);
        }
      `;

      const prog = link(compile(gl.VERTEX_SHADER, VS), compile(gl.FRAGMENT_SHADER, FS));
      gl.useProgram(prog);

      const loc = {
        a_pos: gl.getAttribLocation(prog, "a_pos"),
        a_nrm: gl.getAttribLocation(prog, "a_nrm"),
        u_vp: gl.getUniformLocation(prog, "u_vp"),
        u_objPos: gl.getUniformLocation(prog, "u_objPos"),
        u_objScale: gl.getUniformLocation(prog, "u_objScale"),
        u_color: gl.getUniformLocation(prog, "u_color"),
        u_lightDir: gl.getUniformLocation(prog, "u_lightDir"),
        u_alpha: gl.getUniformLocation(prog, "u_alpha"),
      };

      /* ========== CUBE GEOMETRY ========== */
      const cube = (() => {
        const P=[], N=[];
        function face(nx,ny,nz, ax,ay,az, bx,by,bz, cx,cy,cz, dx,dy,dz){
          const v = [
            ax,ay,az, bx,by,bz, cx,cy,cz,
            ax,ay,az, cx,cy,cz, dx,dy,dz
          ];
          for(let i=0;i<v.length;i+=3){
            P.push(v[i],v[i+1],v[i+2]);
            N.push(nx,ny,nz);
          }
        }
        face(0,0,1,   -0.5,-0.5,0.5,  0.5,-0.5,0.5,  0.5,0.5,0.5,  -0.5,0.5,0.5);
        face(0,0,-1,   0.5,-0.5,-0.5, -0.5,-0.5,-0.5, -0.5,0.5,-0.5, 0.5,0.5,-0.5);
        face(1,0,0,    0.5,-0.5,0.5,   0.5,-0.5,-0.5,  0.5,0.5,-0.5,  0.5,0.5,0.5);
        face(-1,0,0,  -0.5,-0.5,-0.5, -0.5,-0.5,0.5,  -0.5,0.5,0.5, -0.5,0.5,-0.5);
        face(0,1,0,   -0.5,0.5,0.5,    0.5,0.5,0.5,   0.5,0.5,-0.5, -0.5,0.5,-0.5);
        face(0,-1,0,  -0.5,-0.5,-0.5,  0.5,-0.5,-0.5, 0.5,-0.5,0.5, -0.5,-0.5,0.5);
        return { P:new Float32Array(P), N:new Float32Array(N), count:P.length/3 };
      })();

      const vboPos = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
      gl.bufferData(gl.ARRAY_BUFFER, cube.P, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(loc.a_pos);
      gl.vertexAttribPointer(loc.a_pos, 3, gl.FLOAT, false, 0, 0);

      const vboNrm = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vboNrm);
      gl.bufferData(gl.ARRAY_BUFFER, cube.N, gl.STATIC_DRAW);
      gl.enableVertexAttribArray(loc.a_nrm);
      gl.vertexAttribPointer(loc.a_nrm, 3, gl.FLOAT, false, 0, 0);

      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.clearColor(0.08,0.08,0.08,1);

      /* ========== SCENE + STATE ========== */
      const UP = v3(0,1,0);

      const DOMAIN_COLOR = {
        body:   [0.88,0.88,0.88],
        text:   [1.00,0.86,0.86],
        media:  [0.91,0.88,0.96],
        form:   [0.82,0.95,0.90],
        table:  [0.92,0.92,0.80],
        code:   [0.80,0.88,1.00],
        head:   [0.98,0.74,0.34],
        tail:   [0.35,0.70,1.00],
        scanner:[0.96,0.50,0.145],
        accent: [0.96,0.50,0.145],
      };

      const cam = {
        target: v3(0, 0, -220),
        yaw: 0.90,
        pitch: 0.62,
        dist: 920,
        fov: 70*Math.PI/180
      };

      const GRID = 96;          // snap cell size (world units)
      const CUBE = 72;          // cube size
      const HALF = CUBE * 0.5;
      const STACK_H = 46;       // vertical stack spacing
      const groundY = HALF;

      // scanner rectangle in world (XZ plane)
      const scanner = { cx:0, cz:-420, w:640, d:360 };

      const state = {
        blocks: [],
        selected: null,
        dragging: null,
        dragStartGround: null,
        dragStartCell: null,
        pointers: new Map(),
        mode: "none",      // drag | orbit | pinchpan
        orbitLast: null,
        pinch: null,

        // UI
        helpOn: false,
        panel: null,       // export | import | edit | null
        pickerOpen: false,
        historyArmed: false,
        closingViaPop: false,

        // export config
        exportScope: "all",     // all | visual
        previewScripts: false,  // SAFE false, LIVE true
        rawEdit: false,

        // import config
        depthMode: "top",       // top | deep
        importMode: "replace",  // replace | merge

        // project data
        project: {
          sourceName: "EMPTY",
          docLang: "en",
          docTitle: "",
          headHTML: "",
          bodyTailHTML: "",
          importedAt: ""
        },

        // performance
        lastRebuild: 0,
        autoRebuild: true
      };

      function rid(){
        try { return (crypto.randomUUID ? crypto.randomUUID() : ("b_" + Math.random().toString(16).slice(2))); }
        catch(_){ return ("b_" + Math.random().toString(16).slice(2)); }
      }

      function cameraEye(){
        const cp=Math.cos(cam.pitch), sp=Math.sin(cam.pitch);
        const cy=Math.cos(cam.yaw), sy=Math.sin(cam.yaw);
        const dir = v3(sy*cp, sp, cy*cp);
        return add(cam.target, mul(dir, cam.dist));
      }

      function getVP(){
        const aspect = canvas.width / canvas.height;
        const proj = m4.perspective(cam.fov, aspect, 0.1, 6000.0);
        const eye = cameraEye();
        const view = m4.lookAt(eye, cam.target, UP);
        const vp = m4.multiply(proj, view);
        return { proj, view, vp, eye };
      }

      function rayFromScreen(clientX, clientY){
        const nx = (clientX / innerWidth) * 2 - 1;
        const ny = 1 - (clientY / innerHeight) * 2;
        const { vp, eye } = getVP();
        const invVP = m4.invert(vp);
        if(!invVP) return null;
        const near = unproject(nx, ny, -1, invVP);
        const far  = unproject(nx, ny,  1, invVP);
        if(!near || !far) return null;
        const dir = norm(sub(far, near));
        return { o: eye, d: dir };
      }

      function intersectPlaneY(ray, y){
        const denom = ray.d.y;
        if(Math.abs(denom) < 1e-6) return null;
        const t = (y - ray.o.y) / denom;
        if(t <= 0) return null;
        return add(ray.o, mul(ray.d, t));
      }

      function intersectAABB(ray, min, max){
        let tmin=-Infinity, tmax=Infinity;
        for(const ax of ["x","y","z"]){
          const o = ray.o[ax], d = ray.d[ax];
          if(Math.abs(d) < 1e-8){
            if(o < min[ax] || o > max[ax]) return null;
          } else {
            let t1 = (min[ax] - o)/d;
            let t2 = (max[ax] - o)/d;
            if(t1>t2){ const tmp=t1; t1=t2; t2=tmp; }
            tmin = Math.max(tmin, t1);
            tmax = Math.min(tmax, t2);
            if(tmin>tmax) return null;
          }
        }
        if(tmax < 0) return null;
        return tmin >= 0 ? tmin : tmax;
      }

      function blockScale(b){
        // all visual blocks are cubes; non-visual head/tail blocks are shown too but on a rack
        return v3(CUBE, CUBE, CUBE);
      }

      function pickBlock(clientX, clientY){
        const ray = rayFromScreen(clientX, clientY);
        if(!ray) return null;
        let best=null, bestT=Infinity;
        for(const b of state.blocks){
          if(!b.visual) continue; // pick only visual cubes in the world space editor
          const p=b.pos;
          const min=v3(p.x-HALF, p.y-HALF, p.z-HALF);
          const max=v3(p.x+HALF, p.y+HALF, p.z+HALF);
          const t = intersectAABB(ray, min, max);
          if(t !== null && t < bestT){ bestT=t; best=b; }
        }
        return best;
      }

      function snapCell(x, z){
        const cx = Math.round(x / GRID);
        const cz = Math.round(z / GRID);
        return { cx, cz, x: cx * GRID, z: cz * GRID };
      }
      function cellKey(cx,cz){ return cx + "," + cz; }

      function stacksForCell(cx,cz){
        const key = cellKey(cx,cz);
        const arr = [];
        for(const b of state.blocks){
          if(!b.visual) continue;
          if(b.cx === cx && b.cz === cz) arr.push(b);
        }
        arr.sort((a,b)=>a.stack - b.stack);
        return arr;
      }

      function normalizeStacks(){
        // ensure stacks are 0..n for each cell, no duplicates
        const map = new Map();
        for(const b of state.blocks){
          if(!b.visual) continue;
          const k = cellKey(b.cx,b.cz);
          if(!map.has(k)) map.set(k, []);
          map.get(k).push(b);
        }
        for(const [k, arr] of map.entries()){
          arr.sort((a,b)=>a.stack - b.stack || (a._ord - b._ord));
          for(let i=0;i<arr.length;i++){
            arr[i].stack = i;
            arr[i].pos.y = groundY + i * STACK_H;
          }
        }
      }

      function escapeHTML(s){
        return String(s)
          .replaceAll("&","&amp;")
          .replaceAll("<","&lt;")
          .replaceAll(">","&gt;")
          .replaceAll('"',"&quot;")
          .replaceAll("'","&#039;");
      }

      function parseAttrLines(text){
        const lines = String(text||"").split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
        const attrs = {};
        for(const ln of lines){
          // allow: key="value" OR key='value' OR key=value OR boolean key
          const m = ln.match(/^([a-zA-Z_:][-a-zA-Z0-9_:.]*)(?:\s*=\s*(.+))?$/);
          if(!m) continue;
          const k = m[1];
          let v = (m[2] ?? "").trim();
          if(!v){
            attrs[k] = "";
            continue;
          }
          // strip surrounding quotes if present
          if((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))){
            v = v.slice(1,-1);
          }
          attrs[k] = v;
        }
        return attrs;
      }

      function attrsToLines(attrsObj){
        const keys = Object.keys(attrsObj||{});
        return keys.map(k=>{
          const v = attrsObj[k];
          if(v === "") return k;
          return `${k}="${String(v).replaceAll('"','&quot;')}"`;
        }).join("\n");
      }

      function tagDomain(tag, domainHint){
        const t = String(tag||"div").toLowerCase();
        if(domainHint === "head") return "head";
        if(domainHint === "tail") return "tail";

        // body classification (for color)
        if(["h1","h2","h3","h4","h5","h6","p","span","a","strong","em","code","pre","blockquote"].includes(t)) return "text";
        if(["img","video","audio","canvas","svg","iframe","picture","source"].includes(t)) return "media";
        if(["form","input","textarea","select","option","label","button","fieldset","legend"].includes(t)) return "form";
        if(["table","thead","tbody","tfoot","tr","th","td"].includes(t)) return "table";
        if(["script","style","link","meta","title"].includes(t)) return "code";
        return "body";
      }

      function makeOuterHTML(tag, domain, content, attrs){
        const t = String(tag||"div").toLowerCase();
        const a = attrs || {};
        // special handling:
        // - img/src
        // - a/href
        // - input/value/placeholder
        // - meta/link/script/style specifics if user uses content/attrs
        const el = document.createElement(t === "svg" ? "div" : "template"); // svg outerHTML via template is fine if user supplies raw
        // We'll build with DOM when possible
        let node = null;
        try{
          node = document.createElement(t);
        }catch(_){
          node = document.createElement("div");
          node.setAttribute("data-bad-tag", t);
        }

        // apply attrs
        for(const k of Object.keys(a)){
          try{
            if(a[k] === "") node.setAttribute(k, "");
            else node.setAttribute(k, String(a[k]));
          }catch(_){}
        }

        // apply content according to tag
        const c = String(content ?? "");
        if(t === "img"){
          if(!node.getAttribute("src")) node.setAttribute("src", c.trim() || "data:image/svg+xml;charset=utf-8," + encodeURIComponent(
            `<svg xmlns="http://www.w3.org/2000/svg" width="160" height="80">
              <rect width="100%" height="100%" fill="#ddd"/>
              <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#333"
                font-family="Arial" font-size="14">IMG</text>
            </svg>`
          ));
          if(!node.getAttribute("alt")) node.setAttribute("alt","");
        } else if(t === "a"){
          if(!node.getAttribute("href")) node.setAttribute("href", c.trim() || "#");
          if(!node.textContent) node.textContent = c.trim() || "link";
        } else if(t === "input"){
          if(!node.getAttribute("value") && c.trim()) node.setAttribute("value", c.trim());
          if(!node.getAttribute("placeholder") && !c.trim()) node.setAttribute("placeholder", "input");
        } else if(t === "meta"){
          // meta has no inner content
        } else if(t === "link"){
          // link has no inner content
        } else if(t === "script" || t === "style"){
          node.textContent = c;
        } else if(["hr","br"].includes(t)){
          // void-ish
        } else {
          node.textContent = c;
        }

        return node.outerHTML;
      }

      function makeBlock({ tag, domain, content, attrs, outerHTML, visual=true }){
        const id = rid();
        const t = String(tag||"div").toLowerCase();
        const dom = domain || "body";
        const domColor = tagDomain(t, dom);

        // spawn near camera target
        const spawn = v3(cam.target.x + (Math.random()*220-110), groundY, cam.target.z + 220 + (Math.random()*120-60));
        const cell = snapCell(spawn.x, spawn.z);

        const b = {
          id,
          tag: t,
          domain: dom,
          domainColor: domColor,
          content: content ?? "",
          attrs: attrs || {},
          outerHTML: outerHTML || "",
          useRaw: false,

          visual: !!visual, // only body blocks are draggable cubes
          pos: v3(cell.x, groundY, cell.z),
          cx: cell.cx,
          cz: cell.cz,
          stack: 0,

          _ord: state.blocks.length + 1
        };

        // assign stack for this cell
        const existing = stacksForCell(b.cx, b.cz);
        b.stack = existing.length;
        b.pos.y = groundY + b.stack * STACK_H;

        return b;
      }

      function addBlock(tag, domain){
        const t = String(tag||"div").toLowerCase();
        const dom = domain || "body";
        const dcol = tagDomain(t, dom);

        const defaultContent = (() => {
          if(["h1","h2","h3"].includes(t)) return "Hello";
          if(t === "p") return "Paragraph";
          if(t === "span") return "Span";
          if(t === "div") return "Box";
          if(t === "button") return "Click";
          if(t === "a") return "https://example.com";
          if(t === "img") return "";
          if(t === "input") return "";
          if(t === "script") return "// script";
          if(t === "style") return "/* css */";
          if(t === "title") return "Untitled";
          return "";
        })();

        const attrs = {};
        if(t === "a") attrs.href = "https://example.com";
        if(t === "img") attrs.alt = "";
        if(t === "iframe") attrs.src = "about:blank";

        const outer = makeOuterHTML(t, dom, defaultContent, attrs);

        const visual = (dom === "body"); // head/tail blocks are stored in project instead
        const b = makeBlock({ tag:t, domain:dom, content:defaultContent, attrs, outerHTML:outer, visual:true });

        // HEAD blocks are still represented as cubes, but placed on a "rack" to the side (not exported as positioned)
        if(dom === "head" || dom === "tail"){
          b.domain = dom;
          b.domainColor = (dom === "head") ? "head" : "tail";
          b.visual = true;
          // rack position
          const rx = (dom === "head") ? -720 : 720;
          const rz = cam.target.z + 80;
          const cell = snapCell(rx, rz);
          b.pos.x = cell.x; b.pos.z = cell.z;
          b.cx = cell.cx; b.cz = cell.cz;
        }

        state.blocks.push(b);
        state.selected = b.id;
        normalizeStacks();
        rebuildExport(true);
        toast(`Added <${t}> (${dom.toUpperCase()})`);
      }

      function deleteSelected(){
        if(!state.selected) return;
        const i = state.blocks.findIndex(b => b.id === state.selected);
        if(i >= 0){
          const removed = state.blocks.splice(i,1)[0];
          state.selected = null;
          normalizeStacks();
          rebuildExport(true);
          toast(`Deleted <${removed.tag}>`);
        }
      }

      function inScanner(b){
        const left=scanner.cx-scanner.w/2, right=scanner.cx+scanner.w/2;
        const back=scanner.cz-scanner.d/2, front=scanner.cz+scanner.d/2;
        const p=b.pos;
        return (p.x>=left && p.x<=right && p.z>=back && p.z<=front);
      }

      /* ========== EXPORT (ROUNDTRIP) ========== */
      function stripS420LayoutFromHead(headHTML){
        // remove previous injected S420 layout block by marker
        const s = String(headHTML||"");
        const start = s.indexOf("/* S420_LAYOUT_START */");
        const end   = s.indexOf("/* S420_LAYOUT_END */");
        if(start !== -1 && end !== -1 && end > start){
          return (s.slice(0, start) + s.slice(end + "/* S420_LAYOUT_END */".length)).trim();
        }
        return s;
      }

      function buildS420LayoutCSS(blocks){
        // project 3D (x,z,stack) into CSS absolute positions
        // x -> horizontal px, z -> vertical px (inverted)
        // stack lifts upward visually
        const lines = [];
        lines.push("/* S420_LAYOUT_START */");
        lines.push(":root{ --s420-origin-x: 50vw; --s420-origin-y: 50vh; }");
        lines.push("body{ position:relative; min-height:100vh; }");
        lines.push("[data-s420-id]{ position:absolute; left:var(--s420-origin-x); top:var(--s420-origin-y); transform: translate3d(calc(var(--s420-x)*1px), calc(var(--s420-z)*0.85px - var(--s420-stack)*42px), 0) translate(-50%,-50%); }");
        lines.push("[data-s420-id][data-s420-hidden='1']{ display:none !important; }");
        for(const b of blocks){
          const x = Math.round(b.pos.x);
          const z = Math.round(-b.pos.z); // invert for screen Y
          const st = b.stack|0;
          const zi = 1000 + st;
          lines.push(`[data-s420-id="${b.id}"]{ --s420-x:${x}; --s420-z:${z}; --s420-stack:${st}; z-index:${zi}; }`);
        }
        lines.push("/* S420_LAYOUT_END */");
        return "<style id=\"s420-layout\">\\n" + lines.join("\\n") + "\\n</style>";
      }

      function nodeFromOuterHTML(outerHTML, fallbackTag){
        const html = String(outerHTML||"").trim();
        const t = document.createElement("template");
        try{
          t.innerHTML = html;
          const el = t.content.firstElementChild;
          if(el) return el;
        }catch(_){}
        // fallback
        try{ return document.createElement(String(fallbackTag||"div").toLowerCase()); }catch(_){ return document.createElement("div"); }
      }

      function serializeBlockElement(b){
        // produce outerHTML with data-s420-id attached, without breaking scripts/backticks/etc.
        if(b.useRaw && state.rawEdit && String(b.outerHTML||"").trim()){
          const el = nodeFromOuterHTML(b.outerHTML, b.tag);
          el.setAttribute("data-s420-id", b.id);
          el.setAttribute("data-s420-tag", b.tag);
          el.setAttribute("data-s420-domain", b.domain);
          return el.outerHTML;
        }

        const t = String(b.tag||"div").toLowerCase();
        const el = document.createElement(t);

        // attrs
        for(const k of Object.keys(b.attrs||{})){
          try{
            const v = b.attrs[k];
            if(v === "") el.setAttribute(k, "");
            else el.setAttribute(k, String(v));
          }catch(_){}
        }

        // content rules
        const c = String(b.content ?? "");
        if(t === "img"){
          if(!el.getAttribute("src")) el.setAttribute("src", c.trim() || "data:image/svg+xml;charset=utf-8," + encodeURIComponent(
            `<svg xmlns="http://www.w3.org/2000/svg" width="160" height="80">
              <rect width="100%" height="100%" fill="#ddd"/>
              <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#333"
                font-family="Arial" font-size="14">IMG</text>
            </svg>`
          ));
          if(!el.getAttribute("alt")) el.setAttribute("alt","");
        } else if(t === "a"){
          if(!el.getAttribute("href")) el.setAttribute("href", c.trim() || "#");
          el.textContent = c.trim() || el.textContent || "link";
        } else if(t === "input"){
          if(c.trim() && !el.getAttribute("value")) el.setAttribute("value", c.trim());
          if(!c.trim() && !el.getAttribute("placeholder")) el.setAttribute("placeholder","input");
        } else if(t === "script" || t === "style"){
          el.textContent = c;
        } else if(["meta","link","hr","br"].includes(t)){
          // nothing
        } else {
          el.textContent = c;
        }

        el.setAttribute("data-s420-id", b.id);
        el.setAttribute("data-s420-tag", b.tag);
        el.setAttribute("data-s420-domain", b.domain);
        return el.outerHTML;
      }

      function getHeadBlocksHTML(){
        // from blocks domain=head and tag in head set, in their current order
        const headBlocks = state.blocks.filter(b => b.domain === "head");
        if(!headBlocks.length){
          // preserve imported head if any
          return stripS420LayoutFromHead(state.project.headHTML || "");
        }
        return headBlocks.map(b => serializeBlockElement(b)).join("\n");
      }

      function getTailBlocksHTML(){
        const tailBlocks = state.blocks.filter(b => b.domain === "tail");
        if(!tailBlocks.length){
          return (state.project.bodyTailHTML || "");
        }
        return tailBlocks.map(b => serializeBlockElement(b)).join("\n");
      }

      function rebuildExport(force=false){
        const now = performance.now();
        if(!force && (now - state.lastRebuild < 120)) return;
        state.lastRebuild = now;

        // determine export set
        const allVisual = state.blocks.filter(b => b.visual && b.domain === "body");
        const visualBlocks = (state.exportScope === "visual")
          ? allVisual
          : allVisual;

        // HEAD: imported head (minus old s420) + new layout + optional base meta
        const lang = state.project.docLang || "en";
        const title = state.project.docTitle || "Untitled";

        let headHTML = stripS420LayoutFromHead(state.project.headHTML || "");
        // If user created head blocks, override imported head content
        const headFromBlocks = getHeadBlocksHTML().trim();
        if(headFromBlocks) headHTML = headFromBlocks;

        const layoutStyle = buildS420LayoutCSS(visualBlocks);

        // BODY
        // Keep block order stable by original _ord, but layout is via CSS
        const bodyParts = visualBlocks
          .slice()
          .sort((a,b)=>a._ord - b._ord)
          .map(b => serializeBlockElement(b))
          .join("\n");

        // TAIL
        let tailHTML = state.project.bodyTailHTML || "";
        const tailFromBlocks = getTailBlocksHTML().trim();
        if(tailFromBlocks) tailHTML = tailFromBlocks;

        const doc =
`<!doctype html>
<html lang="${escapeHTML(lang)}">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>${escapeHTML(title)}</title>
${headHTML}
${layoutStyle}
</head>
<body>
${bodyParts}
${tailHTML}
</body>
</html>`;

        exportCode.value = doc;
        exportStats.textContent = `blocks=${state.blocks.length} ‚Ä¢ visual=${allVisual.length} ‚Ä¢ exportChars=${doc.length} ‚Ä¢ scope=${state.exportScope.toUpperCase()} ‚Ä¢ preview=${state.previewScripts ? "LIVE" : "SAFE"}`;
      }

      /* ========== PREVIEW (optional - safe by default) ========== */
      function maybePreview(){
        // (Kept in system; we don't embed iframe here to keep UI minimal; export is authoritative.)
        // If you want preview later, add an iframe panel. Current request is stable export/copy/back.
      }

      /* ========== CLIPBOARD + DOWNLOAD (robust) ========== */
      async function copyTextToClipboard(text){
        const t = String(text || "");
        try{
          if(navigator.clipboard && navigator.clipboard.writeText){
            await navigator.clipboard.writeText(t);
            return true;
          }
        }catch(_){}
        try{
          const ta = document.createElement("textarea");
          ta.value = t;
          ta.setAttribute("readonly","");
          ta.style.position="fixed";
          ta.style.left="-9999px";
          ta.style.top="0";
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          const ok = document.execCommand && document.execCommand("copy");
          document.body.removeChild(ta);
          return !!ok;
        }catch(_){ return false; }
      }

      function downloadText(filename, text){
        try{
          const blob = new Blob([String(text||"")], { type:"text/html;charset=utf-8" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
          return true;
        }catch(_){ return false; }
      }

      function safeFilenameBase(){
        const base = (state.project.sourceName && state.project.sourceName !== "EMPTY") ? state.project.sourceName : "s420_export";
        return String(base).replace(/[^a-z0-9_\-]+/gi,"_").toLowerCase().slice(0,48) || "s420_export";
      }

      /* ========== PANELS / NAV (ANDROID BACK FIX) ========== */
      function setPicker(open){
        state.pickerOpen = !!open;
        picker.classList.toggle("open", !!open);
        if(open){
          // focus search without forcing keyboard if not wanted
          setTimeout(()=>{ try{ pickerSearch.focus(); }catch(_){ } }, 50);
        }
      }

      function setScrim(open){
        scrim.classList.toggle("open", !!open);
      }

      function closeAllUI(){
        setPicker(false);
        closePanel(true);
        state.helpOn = false;
        hint.style.display = "none";
      }

      function closePanelFromPop(){
        state.closingViaPop = true;
        state.panel = null;

        panelExport.classList.remove("open");
        panelExport.setAttribute("aria-hidden","true");
        panelImport.classList.remove("open");
        panelImport.setAttribute("aria-hidden","true");
        panelEdit.classList.remove("open");
        panelEdit.setAttribute("aria-hidden","true");

        setScrim(false);
        setPicker(false);

        state.historyArmed = false;
        setTimeout(()=>{ state.closingViaPop = false; }, 0);
      }

      function openPanel(name){
        state.panel = name;

        panelExport.classList.toggle("open", name==="export");
        panelExport.setAttribute("aria-hidden", name==="export" ? "false" : "true");
        panelImport.classList.toggle("open", name==="import");
        panelImport.setAttribute("aria-hidden", name==="import" ? "false" : "true");
        panelEdit.classList.toggle("open", name==="edit");
        panelEdit.setAttribute("aria-hidden", name==="edit" ? "false" : "true");

        setScrim(true);
        setPicker(false);

        // Arm back stack once per open cycle
        if(!state.historyArmed){
          history.pushState({ s420panel:true }, "");
          state.historyArmed = true;
        }

        // focus appropriate field
        if(name==="export"){
          rebuildExport(true);
          setTimeout(()=>{ try{ exportCode.focus(); }catch(_){ } }, 60);
        } else if(name==="import"){
          setTimeout(()=>{ try{ importText.focus(); }catch(_){ } }, 60);
        } else if(name==="edit"){
          loadSelectedIntoEditor();
          setTimeout(()=>{ try{ editTag.focus(); }catch(_){ } }, 60);
        }
      }

      function closePanel(forceNoBack=false){
        if(!state.panel) return;
        if(state.historyArmed && !state.closingViaPop && !forceNoBack){
          history.back(); // popstate will close reliably
          return;
        }
        closePanelFromPop();
      }

      window.addEventListener("popstate", ()=>{
        if(state.historyArmed && state.panel){
          closePanelFromPop();
        }
      });

      scrim.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        closeAllUI();
      }, {passive:false});

      /* ========== HINT TEXT ========== */
      hint.textContent =
`Controls:
‚Ä¢ Drag cube: snapped grid (no overlap)
‚Ä¢ Same cell: stacks vertically (levels)
‚Ä¢ Drag empty: orbit camera
‚Ä¢ Pinch: zoom
‚Ä¢ Two-finger drag: pan target

UI:
‚Ä¢ Tap scrim or ‚úï to close panels
‚Ä¢ Android BACK closes panels (fixed)
Export:
‚Ä¢ COPY (may be blocked) ‚Üí use SELECT + long-press ‚Üí Copy
‚Ä¢ DOWNLOAD always works`;

      /* ========== PICKER SEARCH + TABS ========== */
      function applyPickerSearch(){
        const q = String(pickerSearch.value||"").trim().toLowerCase();
        const pills = picker.querySelectorAll(".pill");
        for(const p of pills){
          const tag = (p.dataset.tag||"").toLowerCase();
          const txt = (p.textContent||"").toLowerCase();
          const ok = !q || tag.includes(q) || txt.includes(q);
          p.style.display = ok ? "" : "none";
        }
      }
      pickerSearch.addEventListener("input", applyPickerSearch, {passive:true});

      picker.addEventListener("pointerdown",(e)=>{
        const tab = e.target.closest(".tab");
        if(tab){
          e.preventDefault(); e.stopPropagation();
          const t = tab.dataset.tab;
          for(const b of picker.querySelectorAll(".tab")) b.classList.toggle("on", b.dataset.tab===t);
          for(const g of picker.querySelectorAll(".pick-grid")) g.classList.toggle("on", g.dataset.grid===t);
          applyPickerSearch();
          return;
        }
        const pill = e.target.closest(".pill");
        if(pill){
          e.preventDefault(); e.stopPropagation();
          const tag = pill.dataset.tag;
          const domain = pill.dataset.domain;
          setPicker(false);
          addBlock(tag, domain);
        }
      }, {passive:false});

      pickerClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); setPicker(false); }, {passive:false});

      /* ========== BUTTONS ========== */
      btnAdd.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        if(state.panel) closePanel(true);
        setPicker(!picker.classList.contains("open"));
      }, {passive:false});

      btnDel.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        deleteSelected();
      }, {passive:false});

      btnHelp.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.helpOn = !state.helpOn;
        hint.style.display = state.helpOn ? "block" : "none";
      }, {passive:false});

      btnExportOpen.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        openPanel("export");
      }, {passive:false});

      btnImportOpen.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        openPanel("import");
        updateImportStats();
      }, {passive:false});

      btnExportClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanel(); }, {passive:false});
      btnImportClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanel(); }, {passive:false});
      btnEditClose.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); closePanel(); }, {passive:false});

      /* ========== EXPORT PANEL ACTIONS ========== */
      btnRebuild.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        rebuildExport(true);
        toast("Rebuilt export.");
      }, {passive:false});

      btnScope.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.exportScope = (state.exportScope === "all") ? "visual" : "all";
        btnScope.textContent = "SCOPE: " + (state.exportScope === "all" ? "ALL" : "VISUAL");
        btnScope.classList.toggle("on", state.exportScope === "all");
        rebuildExport(true);
        toast("Scope: " + state.exportScope.toUpperCase());
      }, {passive:false});

      btnPreviewMode.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.previewScripts = !state.previewScripts;
        btnPreviewMode.textContent = "PREVIEW: " + (state.previewScripts ? "LIVE" : "SAFE");
        btnPreviewMode.classList.toggle("on", state.previewScripts);
        toast("Preview: " + (state.previewScripts ? "LIVE" : "SAFE"));
      }, {passive:false});

      btnCopy.addEventListener("pointerdown", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        rebuildExport(true);
        const ok = await copyTextToClipboard(exportCode.value);
        if(ok) toast("Copied export to clipboard.");
        else toast("Copy blocked. Use SELECT then long-press ‚Üí Copy.");
      }, {passive:false});

      btnSelect.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        try{
          exportCode.focus();
          exportCode.select();
          toast("Selected. Long-press ‚Üí Copy.");
        }catch(_){
          toast("Select failed. Tap inside, then long-press ‚Üí Select All.");
        }
      }, {passive:false});

      btnDownload.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        rebuildExport(true);
        const name = safeFilenameBase() + "_index.html";
        const ok = downloadText(name, exportCode.value);
        toast(ok ? ("Downloaded: " + name) : "Download failed.");
      }, {passive:false});

      /* ========== IMPORT PANEL ACTIONS ========== */
      function updateImportStats(extra=""){
        const t = importText.value || "";
        importStats.textContent = `chars=${t.length} ‚Ä¢ depth=${state.depthMode.toUpperCase()} ‚Ä¢ mode=${state.importMode.toUpperCase()}`
          + (state.project.sourceName ? `\nsource=${state.project.sourceName}` : "")
          + (extra ? ("\n" + extra) : "");
      }
      importText.addEventListener("input", ()=>updateImportStats(), {passive:true});

      btnClearImport.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        importText.value = "";
        state.project.sourceName = "EMPTY";
        state.project.headHTML = "";
        state.project.bodyTailHTML = "";
        state.project.docTitle = "";
        state.project.importedAt = "";
        updateImportStats("Cleared.");
      }, {passive:false});

      btnDepth.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.depthMode = (state.depthMode === "top") ? "deep" : "top";
        btnDepth.textContent = "DEPTH: " + (state.depthMode === "top" ? "TOP" : "DEEP");
        btnDepth.classList.toggle("on", state.depthMode === "top");
        updateImportStats("Depth changed.");
      }, {passive:false});

      btnReplace.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.importMode = (state.importMode === "replace") ? "merge" : "replace";
        btnReplace.textContent = "MODE: " + (state.importMode === "replace" ? "REPLACE" : "MERGE");
        btnReplace.classList.toggle("on", state.importMode === "replace");
        updateImportStats("Mode changed.");
      }, {passive:false});

      btnPaste.addEventListener("pointerdown", async (e)=>{
        e.preventDefault(); e.stopPropagation();
        try{
          if(navigator.clipboard && navigator.clipboard.readText){
            const t = await navigator.clipboard.readText();
            if(!t){ updateImportStats("Clipboard empty."); return; }
            importText.focus();
            importText.value = t;
            updateImportStats(`Pasted ${t.length} chars.`);
          } else {
            updateImportStats("Clipboard read blocked. Long-press ‚Üí Paste.");
          }
        } catch(err){
          updateImportStats("Clipboard blocked. Long-press ‚Üí Paste.");
        }
      }, {passive:false});

      function parseHTMLDocument(html){
        const src = String(html||"");
        const doc = new DOMParser().parseFromString(src, "text/html");
        const lang = (doc.documentElement && doc.documentElement.getAttribute("lang")) || "en";
        const title = (doc.title || "").trim();
        const head = doc.head ? doc.head.innerHTML : "";
        const body = doc.body ? doc.body.innerHTML : "";

        // attempt: collect scripts at end of body as tail candidates
        let bodyTailHTML = "";
        try{
          const bodyChildren = Array.from(doc.body ? doc.body.children : []);
          const tail = [];
          for(const el of bodyChildren){
            const tag = el.tagName.toLowerCase();
            if(tag === "script" || tag === "style"){
              tail.push(el.outerHTML);
            }
          }
          bodyTailHTML = tail.join("\n");
        }catch(_){}

        // BODY VISUAL candidates: ignore scripts/styles by default
        const bodyCandidates = [];
        function isRenderable(el){
          const t = el.tagName.toLowerCase();
          if(t === "script" || t === "style") return false;
          return true;
        }

        const MAX = 700;
        if(doc.body){
          if(state.depthMode === "top"){
            for(const el of Array.from(doc.body.children)){
              if(bodyCandidates.length >= MAX) break;
              if(!isRenderable(el)) continue;
              bodyCandidates.push(el);
            }
          } else {
            // deep traversal with bounding
            const stack = Array.from(doc.body.children);
            while(stack.length && bodyCandidates.length < MAX){
              const el = stack.shift();
              if(!(el && el.tagName)) continue;
              if(isRenderable(el)) bodyCandidates.push(el);
              // traverse children
              for(const ch of Array.from(el.children || [])){
                if(bodyCandidates.length >= MAX) break;
                stack.push(ch);
              }
            }
          }
        }

        return { doc, lang, title, head, body, bodyTailHTML, bodyCandidates };
      }

      function elementToBlock(el, domain){
        const tag = el.tagName.toLowerCase();
        const attrs = {};
        for(const a of Array.from(el.attributes || [])){
          attrs[a.name] = a.value;
        }

        // content heuristics
        let content = "";
        if(tag === "img") content = attrs.src || "";
        else if(tag === "a") content = attrs.href || (el.textContent||"").trim();
        else if(tag === "input") content = attrs.value || attrs.placeholder || "";
        else if(tag === "textarea") content = (el.textContent||"").trim();
        else if(tag === "script" || tag === "style") content = el.textContent || "";
        else content = (el.textContent || "").trim();

        const outerHTML = el.outerHTML || makeOuterHTML(tag, domain, content, attrs);

        const dom = domain || "body";
        const b = makeBlock({ tag, domain: dom, content, attrs, outerHTML, visual:true });
        b.domainColor = tagDomain(tag, dom);
        return b;
      }

      function importVisualize(){
        const src = importText.value || "";
        if(!src.trim()){
          updateImportStats("Nothing to import.");
          return;
        }

        const parsed = parseHTMLDocument(src);

        // update project metadata
        state.project.docLang = parsed.lang || "en";
        state.project.docTitle = parsed.title || "Untitled";
        state.project.headHTML = stripS420LayoutFromHead(parsed.head || "");
        state.project.bodyTailHTML = parsed.bodyTailHTML || "";
        state.project.sourceName = (parsed.title ? parsed.title : "import");
        state.project.importedAt = new Date().toISOString();

        const newBlocks = [];

        // Head blocks: optional (not exploding size) ‚Äî parse head nodes as blocks
        try{
          const headDoc = new DOMParser().parseFromString("<head>" + (parsed.head||"") + "</head>", "text/html");
          const headEls = Array.from(headDoc.head ? headDoc.head.children : []);
          for(const el of headEls){
            const tag = el.tagName.toLowerCase();
            if(["meta","link","style","script","title"].includes(tag)){
              const b = elementToBlock(el, "head");
              b.domain = "head";
              b.domainColor = "head";
              // rack them
              const rx = -720, rz = cam.target.z + 80;
              const cell = snapCell(rx, rz);
              b.pos.x = cell.x; b.pos.z = cell.z; b.cx=cell.cx; b.cz=cell.cz;
              newBlocks.push(b);
            }
          }
        }catch(_){}

        // Body visual blocks
        for(const el of parsed.bodyCandidates){
          const b = elementToBlock(el, "body");
          b.domain = "body";
          b.domainColor = tagDomain(b.tag, "body");
          newBlocks.push(b);
        }

        // Body tail blocks: scripts at end (as tail domain)
        try{
          const tailDoc = new DOMParser().parseFromString("<body>" + (parsed.bodyTailHTML||"") + "</body>", "text/html");
          const tailEls = Array.from(tailDoc.body ? tailDoc.body.children : []);
          for(const el of tailEls){
            const tag = el.tagName.toLowerCase();
            if(tag === "script" || tag === "style"){
              const b = elementToBlock(el, "tail");
              b.domain = "tail";
              b.domainColor = "tail";
              // rack them
              const rx = 720, rz = cam.target.z + 80;
              const cell = snapCell(rx, rz);
              b.pos.x = cell.x; b.pos.z = cell.z; b.cx=cell.cx; b.cz=cell.cz;
              newBlocks.push(b);
            }
          }
        }catch(_){}

        // Apply import mode
        if(state.importMode === "replace"){
          state.blocks.length = 0;
          state.selected = null;
        }

        // Place imported body blocks into a grid near camera, no overlap
        let ix = -4, iz = -3;
        for(const b of newBlocks){
          b._ord = state.blocks.length + 1;
          if(b.domain === "body"){
            const x = cam.target.x + (ix * GRID);
            const z = cam.target.z + (iz * GRID);
            const cell = snapCell(x,z);
            b.pos.x = cell.x; b.pos.z = cell.z;
            b.cx=cell.cx; b.cz=cell.cz;
            ix++;
            if(ix > 4){ ix = -4; iz++; }
          }
          state.blocks.push(b);
        }

        normalizeStacks();
        rebuildExport(true);
        updateImportStats(`Imported: blocks=${newBlocks.length} (body=${newBlocks.filter(b=>b.domain==="body").length})`);
        toast("Imported ‚Üí blocks created.");
        closePanel(); // back out cleanly
      }

      btnVisualize.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        importVisualize();
      }, {passive:false});

      /* ========== EDIT PANEL ========== */
      function getSelected(){
        if(!state.selected) return null;
        return state.blocks.find(b => b.id === state.selected) || null;
      }

      function loadSelectedIntoEditor(){
        const b = getSelected();
        if(!b){
          editInfo.textContent = "no selection";
          editTag.value = "";
          editContent.value = "";
          editAttrs.value = "";
          editOuter.value = "";
          return;
        }
        editInfo.textContent = `id=${b.id}\ntag=<${b.tag}>\ndomain=${b.domain.toUpperCase()}\ncell=${b.cx},${b.cz}\nstack=${b.stack}`;
        editTag.value = b.tag;
        editContent.value = String(b.content ?? "");
        editAttrs.value = attrsToLines(b.attrs);
        editOuter.value = String(b.outerHTML || "");
        btnRaw.textContent = "RAW: " + (state.rawEdit ? "ON" : "OFF");
        btnRaw.classList.toggle("on", state.rawEdit);
      }

      btnRaw.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        state.rawEdit = !state.rawEdit;
        btnRaw.textContent = "RAW: " + (state.rawEdit ? "ON" : "OFF");
        btnRaw.classList.toggle("on", state.rawEdit);
        toast("RAW: " + (state.rawEdit ? "ON" : "OFF"));
      }, {passive:false});

      btnApplyEdit.addEventListener("pointerdown",(e)=>{
        e.preventDefault(); e.stopPropagation();
        const b = getSelected();
        if(!b){ toast("No selection."); return; }

        const newTag = String(editTag.value||"div").trim().toLowerCase() || "div";
        b.tag = newTag;

        b.content = String(editContent.value ?? "");
        b.attrs = parseAttrLines(editAttrs.value || "");
        b.outerHTML = String(editOuter.value || "");

        // Update domainColor based on tag+domain
        b.domainColor = tagDomain(b.tag, b.domain);

        rebuildExport(true);
        toast("Applied.");
      }, {passive:false});

      function adjustStack(delta){
        const b = getSelected();
        if(!b || !b.visual) return;
        const cellBlocks = stacksForCell(b.cx, b.cz);
        if(!cellBlocks.length) return;
        const max = cellBlocks.length - 1;
        const next = clamp(b.stack + delta, 0, max);

        // swap stack indices with whoever occupies that level
        const other = cellBlocks.find(x=>x.stack === next);
        if(other && other !== b){
          const tmp = other.stack;
          other.stack = b.stack;
          b.stack = tmp;
        } else {
          b.stack = next;
        }
        normalizeStacks();
        rebuildExport(true);
        toast("Stack: " + b.stack);
        loadSelectedIntoEditor();
      }

      btnNudgeUp.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); adjustStack(+1); }, {passive:false});
      btnNudgeDown.addEventListener("pointerdown",(e)=>{ e.preventDefault(); e.stopPropagation(); adjustStack(-1); }, {passive:false});

      /* ========== RENDERING ========== */
      function drawCube(pos, scale, color, alpha){
        gl.uniform3f(loc.u_objPos, pos.x, pos.y, pos.z);
        gl.uniform3f(loc.u_objScale, scale.x, scale.y, scale.z);
        gl.uniform3f(loc.u_color, color[0], color[1], color[2]);
        gl.uniform3f(loc.u_lightDir, -0.35, 0.90, 0.25);
        gl.uniform1f(loc.u_alpha, alpha);
        gl.drawArrays(gl.TRIANGLES, 0, cube.count);
      }

      function drawScanner(vp){
        gl.uniformMatrix4fv(loc.u_vp, false, vp);

        const left=scanner.cx-scanner.w/2, right=scanner.cx+scanner.w/2;
        const back=scanner.cz-scanner.d/2, front=scanner.cz+scanner.d/2;

        // thin slab
        const y = 0.8;
        const w = scanner.w, d = scanner.d;
        drawCube(v3(scanner.cx, y, scanner.cz), v3(w, 1.8, d), DOMAIN_COLOR.scanner, 0.08);

        // corners
        const c = DOMAIN_COLOR.scanner;
        drawCube(v3(left,  y+0.9, back),  v3(10,10,10), c, 0.85);
        drawCube(v3(right, y+0.9, back),  v3(10,10,10), c, 0.85);
        drawCube(v3(left,  y+0.9, front), v3(10,10,10), c, 0.85);
        drawCube(v3(right, y+0.9, front), v3(10,10,10), c, 0.85);
      }

      function render(){
        resize();
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const { vp } = getVP();
        gl.uniformMatrix4fv(loc.u_vp, false, vp);

        // ground slab
        drawCube(v3(0, -HALF, -320), v3(2400, 6, 2400), [0.20,0.20,0.20], 0.18);

        // a few grid dots for spatial sense
        for(let z=-1200; z<=600; z+=GRID){
          for(let x=-1200; x<=1200; x+=GRID){
            drawCube(v3(x, 0.0, z), v3(8, 1.2, 8), [0.30,0.30,0.30], 0.16);
          }
        }

        drawScanner(vp);

        // blocks
        for(const b of state.blocks){
          if(!b.visual) continue;
          const base = DOMAIN_COLOR[b.domainColor] || DOMAIN_COLOR.body;
          drawCube(b.pos, v3(CUBE, CUBE, CUBE), base, 1.0);

          // Selected highlight shell
          if(state.selected === b.id){
            drawCube(b.pos, v3(CUBE*1.10, CUBE*1.10, CUBE*1.10), DOMAIN_COLOR.accent, 0.22);
          }

          // Domain cap (small slab on top) for stronger differentiation
          const capColor = (b.domain === "head") ? DOMAIN_COLOR.head : (b.domain === "tail") ? DOMAIN_COLOR.tail : (b.domainColor === "media") ? DOMAIN_COLOR.media :
                           (b.domainColor === "form") ? DOMAIN_COLOR.form : (b.domainColor === "text") ? DOMAIN_COLOR.text :
                           (b.domainColor === "table") ? DOMAIN_COLOR.table : (b.domainColor === "code") ? DOMAIN_COLOR.code : DOMAIN_COLOR.body;
          drawCube(v3(b.pos.x, b.pos.y + HALF - 6, b.pos.z), v3(CUBE*0.96, 8, CUBE*0.96), capColor, 0.55);
        }

        requestAnimationFrame(render);
      }

      /* ========== INPUT (DRAG / ORBIT / PINCHPAN) ========== */
      function uiBlocking(){
        return !!(state.panel || state.pickerOpen);
      }

      canvas.addEventListener("pointerdown", (e)=>{
        // If UI open, don't allow world interactions
        if(uiBlocking()) return;

        e.preventDefault();
        canvas.setPointerCapture(e.pointerId);
        state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        // two pointers = pinchpan
        if(state.pointers.size === 2){
          state.mode = "pinchpan";
          state.dragging = null;
          const pts=[...state.pointers.values()];
          const a=pts[0], b=pts[1];
          const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const dist=Math.hypot(a.x-b.x, a.y-b.y) || 1;
          state.pinch = {
            startDist: dist,
            startMid: mid,
            startCamDist: cam.dist,
            startTarget: v3(cam.target.x, cam.target.y, cam.target.z)
          };
          return;
        }

        const picked = pickBlock(e.clientX, e.clientY);
        if(picked){
          state.mode = "drag";
          state.dragging = picked.id;
          state.selected = picked.id;

          const ray = rayFromScreen(e.clientX, e.clientY);
          const g = ray ? intersectPlaneY(ray, groundY) : null;
          state.dragStartGround = g;
          state.dragStartCell = { cx: picked.cx, cz: picked.cz, stack: picked.stack, x: picked.pos.x, z: picked.pos.z };

          // open editor quickly if desired (not auto)
          rebuildExport(false);
          return;
        }

        state.mode = "orbit";
        state.selected = null;
        state.orbitLast = { x:e.clientX, y:e.clientY };
      }, {passive:false});

      canvas.addEventListener("pointermove",(e)=>{
        if(!state.pointers.has(e.pointerId)) return;
        if(uiBlocking()) return;

        e.preventDefault();
        state.pointers.set(e.pointerId, { x:e.clientX, y:e.clientY });

        if(state.pointers.size === 2 && state.mode === "pinchpan" && state.pinch){
          const pts=[...state.pointers.values()];
          const a=pts[0], b=pts[1];
          const mid={ x:(a.x+b.x)/2, y:(a.y+b.y)/2 };
          const dist=Math.hypot(a.x-b.x, a.y-b.y) || 1;

          const scale = dist / (state.pinch.startDist || dist);
          cam.dist = clamp(state.pinch.startCamDist / scale, 320, 2800);

          const mdx = mid.x - state.pinch.startMid.x;
          const mdy = mid.y - state.pinch.startMid.y;

          const eye = cameraEye();
          const fwd = norm(sub(cam.target, eye));
          const right = norm(cross(fwd, UP));
          const fwdXZ = norm(v3(fwd.x,0,fwd.z));
          const rightXZ = norm(v3(right.x,0,right.z));

          const panFactor = (cam.dist / 980) * 1.05;
          const pan = add(mul(rightXZ, -mdx*panFactor), mul(fwdXZ, mdy*panFactor));
          cam.target = add(state.pinch.startTarget, pan);
          cam.target.y = 0;
          return;
        }

        if(state.mode === "drag" && state.dragging){
          const b = state.blocks.find(x=>x.id===state.dragging);
          if(!b) return;

          const ray = rayFromScreen(e.clientX, e.clientY);
          const g = ray ? intersectPlaneY(ray, groundY) : null;
          if(!g) return;

          // snap target cell
          const cell = snapCell(g.x, g.z);

          // If moved to another cell, place on top stack there (no overlap)
          if(cell.cx !== b.cx || cell.cz !== b.cz){
            b.cx = cell.cx; b.cz = cell.cz;
            b.pos.x = cell.x; b.pos.z = cell.z;

            // stack on top of existing blocks in that cell (excluding self)
            const existing = stacksForCell(b.cx, b.cz).filter(x=>x.id !== b.id);
            b.stack = existing.length;
            b.pos.y = groundY + b.stack * STACK_H;

            normalizeStacks();
          } else {
            // same cell: keep same stack, just snap position
            b.pos.x = cell.x; b.pos.z = cell.z;
            b.pos.y = groundY + b.stack * STACK_H;
          }

          // Rebuild export throttled
          const now = performance.now();
          if(now - state.lastRebuild > 140) rebuildExport(false);

          return;
        }

        if(state.mode === "orbit" && state.orbitLast){
          const dx=e.clientX-state.orbitLast.x;
          const dy=e.clientY-state.orbitLast.y;
          state.orbitLast.x=e.clientX;
          state.orbitLast.y=e.clientY;

          cam.yaw += dx * 0.0056;
          cam.pitch = clamp(cam.pitch - dy * 0.0056, 0.12, 1.35);
          return;
        }
      }, {passive:false});

      function endPointer(e){
        if(state.pointers.has(e.pointerId)) state.pointers.delete(e.pointerId);
        if(state.pointers.size < 2 && state.mode==="pinchpan"){
          state.mode = "none";
          state.pinch = null;
        }
        if(state.pointers.size === 0){
          state.mode = "none";
          state.dragging = null;
          state.dragStartGround = null;
          state.dragStartCell = null;
          state.orbitLast = null;
          rebuildExport(false);
        }
      }
      canvas.addEventListener("pointerup", endPointer, {passive:true});
      canvas.addEventListener("pointercancel", endPointer, {passive:true});

      /* ========== OPEN EDIT PANEL VIA DOUBLE TAP (optional) ========== */
      let lastTapT = 0;
      canvas.addEventListener("pointerdown",(e)=>{
        if(uiBlocking()) return;
        const t = performance.now();
        const dt = t - lastTapT;
        lastTapT = t;
        if(dt < 260){
          // double tap => edit selected
          const picked = pickBlock(e.clientX, e.clientY);
          if(picked){
            state.selected = picked.id;
            openPanel("edit");
          }
        }
      }, {passive:false});

      /* ========== SEED BLOCKS (VISIBLE) ========== */
      function seed(){
        state.blocks.push(makeBlock({ tag:"h1", domain:"body", content:"Hello", attrs:{}, outerHTML:"<h1>Hello</h1>", visual:true }));
        state.blocks.push(makeBlock({ tag:"div", domain:"body", content:"Box", attrs:{}, outerHTML:"<div>Box</div>", visual:true }));
        state.blocks.push(makeBlock({ tag:"img", domain:"body", content:"", attrs:{ alt:"" }, outerHTML:"<img alt=\"\" />", visual:true }));
        state.blocks.push(makeBlock({ tag:"button", domain:"body", content:"Click", attrs:{}, outerHTML:"<button>Click</button>", visual:true }));

        // spread them a bit
        const b0 = state.blocks[0]; b0.pos.x -= GRID*2; b0.pos.z -= GRID*1; b0.cx = snapCell(b0.pos.x,b0.pos.z).cx; b0.cz=snapCell(b0.pos.x,b0.pos.z).cz;
        const b1 = state.blocks[1]; b1.pos.x += 0;       b1.pos.z -= GRID*1; b1.cx = snapCell(b1.pos.x,b1.pos.z).cx; b1.cz=snapCell(b1.pos.x,b1.pos.z).cz;
        const b2 = state.blocks[2]; b2.pos.x += GRID*2;  b2.pos.z -= GRID*1; b2.cx = snapCell(b2.pos.x,b2.pos.z).cx; b2.cz=snapCell(b2.pos.x,b2.pos.z).cz;
        const b3 = state.blocks[3]; b3.pos.x += 0;       b3.pos.z += 0;      b3.cx = snapCell(b3.pos.x,b3.pos.z).cx; b3.cz=snapCell(b3.pos.x,b3.pos.z).cz;

        normalizeStacks();
        state.selected = b0.id;
      }

      seed();
      rebuildExport(true);
      render();

      /* ========== QUICK EDIT OPEN ON SELECTION CHANGE ========== */
      // allow opening edit from export/import without breaking touch
      document.addEventListener("keydown",(e)=>{
        if(e.key === "Escape") closeAllUI();
      });

      /* ========== KEEP EXPORT FRESH IF USER TYPES IN EXPORT BOX ========== */
      exportCode.addEventListener("focus", ()=>rebuildExport(true), {passive:true});

      /* ========== EXTRA: long-press in world to open edit ========== */
      let pressTimer = null;
      canvas.addEventListener("pointerdown",(e)=>{
        if(uiBlocking()) return;
        if(e.pointerType !== "touch") return;
        const picked = pickBlock(e.clientX, e.clientY);
        if(!picked) return;
        clearTimeout(pressTimer);
        pressTimer = setTimeout(()=>{
          state.selected = picked.id;
          openPanel("edit");
        }, 520);
      }, {passive:false});
      canvas.addEventListener("pointerup", ()=>clearTimeout(pressTimer), {passive:true});
      canvas.addEventListener("pointercancel", ()=>clearTimeout(pressTimer), {passive:true});

      /* ========== OPEN EDIT VIA SELECTED + EXPORT BUTTON SECOND TAP ========== */
      btnExportOpen.addEventListener("dblclick", (e)=>{
        e.preventDefault(); e.stopPropagation();
        if(state.selected) openPanel("edit");
      });

      /* ========== AUTO LOAD EDIT FIELDS WHEN OPENING EDIT PANEL ========== */
      const origOpenPanel = openPanel;
      // already loads inside openPanel("edit") via loadSelectedIntoEditor

    })();
  </script>
</body>
        </html>
